\documentclass[a4paper,UKenglish]{lipics-v2016}

\usepackage{microtype}

\bibliographystyle{plainurl}

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Indexing Variation Graphs\footnote{This work was supported by the Wellcome Trust grant [098051].}}

\author[1]{Jouni Sirén}
\affil[1]{Wellcome Trust Sanger Institute, Hinxton, Cambridge, UK\\
  \texttt{jouni.siren@iki.fi}}
\authorrunning{J. Sirén}

\Copyright{Jouni Sirén}

\subjclass{E.1 Data Structures}
\keywords{Burrows-Wheeler transform, de Bruijn graphs, path indexes, variation graphs}
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Mathematics
\newcommand{\set}[1]{\ensuremath{\{ #1 \}}}
\newcommand{\abs}[1]{\ensuremath{\lvert #1 \rvert}}
\newcommand{\Oh}[1]{\ensuremath{\mathsf{O}\!\left( #1 \right)}}

% DNA
\newcommand{\dnaseq}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\baseA}{\dnaseq{A}}
\newcommand{\baseC}{\dnaseq{C}}
\newcommand{\baseG}{\dnaseq{G}}
\newcommand{\baseT}{\dnaseq{T}}
\newcommand{\baseN}{\dnaseq{N}}
\newcommand{\dnacomp}[1]{\ensuremath{\overline{#1}}}
\newcommand{\revcomp}[1]{\ensuremath{\overleftarrow{#1}}}

% Queries
\newcommand{\rank}{\ensuremath{\mathsf{rank}}}
\newcommand{\select}{\ensuremath{\mathsf{select}}}
\newcommand{\LF}{\ensuremath{\mathsf{LF}}}
\newcommand{\find}{\ensuremath{\mathsf{find}}}
\newcommand{\locate}{\ensuremath{\mathsf{locate}}}

% Graphs
\newcommand{\gindegree}{\ensuremath{\mathsf{in}}}
\newcommand{\goutdegree}{\ensuremath{\mathsf{out}}}
\newcommand{\glabel}{\ensuremath{\mathsf{label}}}
\newcommand{\gpred}{\ensuremath{\mathsf{pred}}}
\newcommand{\gkey}{\ensuremath{\mathsf{key}}}
\newcommand{\gvalue}{\ensuremath{\mathsf{value}}}
\newcommand{\gnode}{\ensuremath{\mathsf{node}}}

% Shorthands
\newcommand{\kmer}[1]{$#1$\nobreakdash-mer}
\newcommand{\kcollection}[1]{$#1$\nobreakdash-collection}
\newcommand{\kequivalent}[1]{$#1$\nobreakdash-equivalent}
\newcommand{\orderk}[1]{order\nobreakdash-$#1$}
\newcommand{\LFmapping}{LF\nobreakdash-mapping}
\newcommand{\FMindex}{FM\nobreakdash-index}
\newcommand{\patternset}{\ensuremath{(\Sigma \setminus \set{\#, \$})^{\ast}}}

% Structures
\newcommand{\SA}{\ensuremath{\mathsf{SA}}}
\newcommand{\BWT}{\ensuremath{\mathsf{BWT}}}
\newcommand{\Carray}{\ensuremath{\mathsf{C}}}
\newcommand{\LCP}{\ensuremath{\mathsf{LCP}}}
\newcommand{\bvIN}{\ensuremath{\mathsf{IN}}}
\newcommand{\bvOUT}{\ensuremath{\mathsf{OUT}}}


\begin{document}

\maketitle

\begin{abstract}
Variation graphs, which represent genetic variation within a population, are replacing sequences as reference genomes. Path indexes are one of the most important tools for working with variation graphs. They generalize text indexes for graphs, allowing one to find the paths matching the query string. We propose using pruned de Bruijn graphs as path indexes, encoding them space-efficiently with the Burrows-Wheeler transform. We also generalize many ideas from text indexing literature to work with graphs. The proposed approach has been implemented in the variation graph toolkit vg.
\end{abstract}


\section{Introduction}

1000GP: \cite{1000GP2015}

Graph genomes: \cite{Schneeberger2009}

FM-index: \cite{Ferragina2005a}

XBW: \cite{Ferragina2009b}

GCSA: \cite{Siren2014}

Succinct DBG: \cite{Bowe2012}, variable-order \cite{Boucher2014}, alternative representation \cite{Roedland2013}

BWBBLE: \cite{Huang2013}

Contracted DBG: \cite{Cazaux2014}

Compressed DBG: \cite{Marcus2014}

Hypertext index: \cite{Thachuk2013}

FM-index of alignment: \cite{Na2015}

HISAT / HISAT2: \cite{Kim2015}

Mention that proofs of lemmas are in the appendix


\section{Background}

\subsection{Strings}\label{sect:strings}

A \emph{string} $S[0, n-1] = s_{0} \dotsm s_{n-1}$ of length $\abs{S} = n$ is a sequence of \emph{characters} over an \emph{alphabet} $\Sigma = \set{0, \dotsc, \sigma - 1}$. For indexing purposes, we often consider \emph{text} strings $T[0, n-1]$ terminated by an \emph{endmarker} $T[n-1] = \$ = 0$ not found anywhere else in the text. \emph{Binary} sequences are strings over the alphabet $\set{0, 1}$. A \emph{substring} of string $S$ is a sequence of the form $S[i, j] = s_{i} \dotsm s_{j}$. We call substrings of the type $S[0, j]$ and $S[i, n-1]$ \emph{prefixes} and \emph{suffixes}, respectively, and substrings of length $k$ as \kmer{k}s. We say that string $S'$ is a substring of string collection $\mathcal{S}$, if there is a string $S \in \mathcal{S}$ such that $S'$ is a substring of $S$.

In some cases, we also consider potentially \emph{infinite} character sequences $S = (s_{i})_{i \in Z}$, where set $Z$ is a contiguous infinite subset of $\mathbb{Z}$. The notion of substrings generalizes for such infinite sequences in a natural way. We say that a substring of an infinite sequence $S$ is \emph{left-infinite} if it extends infinitely to the left, and \emph{right-infinite} if it extends infinitely to the right. A substring of a finite or infinite sequence $S$ is \emph{left-maximal} if it is left-infinite or a prefix; \emph{right-maximal} if it is right-infinite or a suffix; and \emph{maximal} if it is both left-maximal and right-maximal.

In this paper, we primarily consider sequences over the \emph{DNA} alphabet $\set{\$, \baseA, \baseC, \baseG, \baseT, \baseN}$. Characters $\baseA$, $\baseC$, $\baseG$, and $\baseT$ are called \emph{bases}, while character $\baseN$ represents an arbitrary or unknown base. In addition to the endmarker $\$$, the alphabet may also contain other characters for technical purposes. Each character $c$ of the DNA alphabet has a \emph{complement} $\dnacomp{c}$ defined as $\dnacomp{\baseA} = \baseT$, $\dnacomp{\baseC} = \baseG$, $\dnacomp{\baseG} = \baseC$, $\dnacomp{\baseT} = \baseA$, and $\dnacomp{c} = c$ for other characters $c$. Given a DNA sequence $S$, its \emph{reverse complement} is the sequence $\revcomp{S}$ obtained by reversing the non-technical parts of the sequence and replacing each character with its complement. For example, $\revcomp{\dnaseq{GATTACA}\$} = \dnaseq{TGTAATC}\$$.

Given string $S[0, n-1]$, we define $S.\rank(i, c)$ to be the number of occurrences of character $c$ in the prefix $S[0, i-1]$. We also define $S.\select(i, c) = \arg \max_{j \le n} S.\rank(j, c) < i$ as the position of the occurrence of character $c$ with rank $i > 0$.\footnote{These definitions are used in the SDSL library \cite{Gog2014b}. We assume for convenience that $S.\select(0, c) = -1$.} A \emph{bitvector} is a binary sequence supporting efficient $\rank$/$\select$ queries. \emph{Wavelet trees} \cite{Grossi2003} are space-efficient data structures that use bitvectors to support $\rank$/$\select$ queries on arbitrary strings.

The following definitions are useful when discussing text indexes and path indexes.

\begin{definition}[Prefix-matching strings]
Let $S$ and $S'$ be strings over alphabet $\Sigma$. We say that string $S$ and $S'$ \emph{prefix-match}, if $S$ is a prefix of $S'$ or $S'$ is a prefix of $S$.
\end{definition}

\begin{definition}[Prefix-free set]
Let $\mathcal{S}$ be a set of strings over alphabet $\Sigma$. We say that set $\mathcal{S}$ is \emph{prefix-free}, if no two strings $S, S' \in \mathcal{S}$ (with $S \ne S'$) prefix-match.
\end{definition}

\subsection{Text indexes}

The \emph{suffix tree} \cite{Weiner1973} is the most fundamental full-text index supporting arbitrary substring queries. It is formed by taking the suffixes of the text, storing them in a trie, and compacting unary paths in the trie into single edges. Although fast and versatile, suffix trees are only of limited use in indexing large texts, as they require much more space than the text itself.

% FIXME SA/BWT/LCP example
\emph{Suffix arrays} \cite{Manber1993} were introduced as a space-efficient alternative to the suffix tree. The suffix array of text $T[0, n-1]$ is an array of pointers $\SA[0, n-1]$ to the suffixes of the text in \emph{lexicographic order}. Given a text and its suffix array, we can find the occurrences of \emph{pattern} string $X$ in the text by using \emph{binary search} in $\Oh{\abs{X} \log n}$ time. The suffix array requires $n \log n$ bits of space in addition to the $n \log \sigma$ bits used by the text --- still much more than the text --- while its functionality is more limited than that of the suffix tree.

The \emph{Burrows-Wheeler transform (BWT)} \cite{Burrows1994} is a permutation of the text with the same combinatorial structure as the suffix array. Given text $T[0, n-1]$, its Burrows-Wheeler transform is a string $\BWT[0, n-1]$, where $\BWT[i] = T[(\SA[i]-1) \bmod n]$. Given the \emph{lexicographic rank} $i$ of suffix $T[\SA[i], n-1]$, we can use \emph{\LFmapping} on the BWT to find the lexicographic rank of the previous suffix $T[(\SA[i]-1) \bmod n, n-1]$. Let
$$
\LF(i) = \Carray[\BWT[i]] + \BWT.\rank(i, \BWT[i]),
$$
where $\Carray[c]$ is the number of occurrences of characters $c' < c$ in the BWT. Then $\SA[\LF(i)] = (\SA[i]-1) \bmod n$. We can also generalize the definition for any character $c \in \Sigma$:
$$
\LF(i, c) = \Carray[c] + \BWT.\rank(i, c).
$$
Let $X$ be a string. If there are $i$ suffixes $S'$ of text $T$ such that $S' < X$ in lexicographic order, then there are $\LF(i, c)$ suffixes smaller than string $cX$ in lexicographic order.

Given the similarities to the suffix array, we can use the BWT as a space-efficient text index. The \emph{\FMindex} \cite{Ferragina2005a} combines a plain or compressed representation of the BWT supporting $\rank$/$\select$ queries, the $\Carray$ array, and a set of \emph{sampled pointers} from the suffix array. It finds the \emph{lexicographic range} of suffixes matching pattern $X$ (having $X$ as a prefix) with a process called \emph{backward searching}. If the lexicographic range matching suffix $X[i+1, \abs{X}-1]$ of the pattern is $\SA[sp, ep]$, then the lexicographic range matching suffix $X[i, \abs{X}-1]$ of the pattern is $\SA[\LF(sp, X[i]), \LF(ep+1, X[i]) - 1]$. Finding the lexicographic range matching the entire pattern requires $\Oh{\abs{X}}$ rank queries.

We can use the sampled suffix array pointers to find the text positions containing the occurrences. If $\SA[i]$ is not sampled, we start iterating $\LF(i)$, until we find a sampled pointer. If we find a sample at $\SA[\LF^{k}(i)]$, we know that
$$
\SA[i] = (\SA[\LF^{k}(i)] + k) \bmod n.
$$
If we have sampled one out of $d$ suffix array pointers at regular intervals, finding each occurrence takes $\Oh{d}$ rank queries. If we also sample one out of $d'$ \emph{inverse suffix array} pointers\footnote{The suffix array is a permutation of $\set{0, \dotsc, n-1}$, and the inverse suffix array is the inverse permutation.}, we can \emph{extract} an arbitrary substring $X$ of the text using $\Oh{\abs{X}+d'}$ rank queries. In a typical case, we expect an \FMindex{} to take less than $n \log \sigma$ bits of space and to be able to find about 100,000 pattern occurrences per second \cite{Ferragina2009a}.

The \emph{longest-common-prefix array} (LCP array) \cite{Manber1993} is an integer array $\LCP[0, n-1]$, where each value $\LCP[i]$ tells the length of the longest common prefix of suffixes $T[\SA[i-1], n-1]$ and $T[\SA[i], n-1]$ (with $\LCP[0] = 0$). It is often used to augment the functionality of the suffix array and the \FMindex. In particular, if we augment the \FMindex{} with the LCP array and the topology of the suffix tree, we get the \emph{compressed suffix tree}, which supports the full functionality of the suffix tree in a space-efficient manner \cite{Sadakane2007}.

\subsection{Graphs}\label{sect:graphs}

A \emph{graph} $G = (V, E)$ consists of a set of \emph{nodes} $V = \set{0, \dotsc, \abs{V}-1}$ and a set of \emph{edges} $E \subseteq V \times V$. We say that $(u, v) \in E$ is an edge \emph{from} node $u$ \emph{to} node $v$, and assume that the edges are \emph{directed}: $(u, v) \ne (v, u)$ for $u \ne v$. The \emph{indegree} $G.\gindegree(v)$ of node $v$ is the number of \emph{incoming} edges to $v$, while the \emph{outdegree} $G.\goutdegree(v)$ is the number of \emph{outgoing} edges from $v$.

The graphs we consider are \emph{labeled} with alphabet $\Sigma$: each node $v \in V$ has a \emph{label} $G.\glabel(v) \in \Sigma$. A \emph{path} in a graph is a sequence of nodes $P = v_{0} \dotsm v_{\abs{P}-1}$ such that $(v_{i}, v_{i+1}) \in E$ for all $i, i+1 \in \set{0, \dotsc, \abs{P}-1}$. We say that $v_{0}$ is the \emph{start} node and $v_{\abs{P}-1}$ is the \emph{end} node of the path. The label of a path is the concatenation of node labels $G.\glabel(P) = G.\glabel(v_{0}) \dotsm G.\glabel(v_{\abs{P}-1})$.

We generalize the definition for infinite paths $P = (v_{i})_{i \in Z}$ in a similar way as we did with infinite character sequences in Section~\ref{sect:strings}. We say that path $P$ is \emph{left-maximal} if it starts at the source node or extends infinitely to the left; \emph{right-maximal} if it ends at the sink node or extends infinitely to the right; and \emph{maximal} if it is both left-maximal and right-maximal.

We assume for convenience that all graphs have two special nodes: the \emph{source} node $s$ and the \emph{sink} node $t$. To distinguish them from the other nodes, we label them with characters $G.\glabel(s) = \#$ and $G.\glabel(t) = \$$. The label of the sink node is unique in the graph, while the label of the source node can be used in other nodes for technical purposes. We add an edge $(s, v)$ for all nodes $v \in V \setminus \set{s}$ that have no other incoming edges, and an edge $(v, t)$ for all nodes $v \in V \setminus \set{t}$ with no other outgoing edges. We also add the edge $(t, s)$ to guarantee that $G.\gindegree(v) \ge 1$ and $G.\goutdegree(v) \ge 1$ for all nodes $v \in V$. However, we assume for convenience that no path in the graph crosses the edge $(t, s)$.

Given a graph $G = (V, E)$, we may want to reason about the \emph{predecessors} of a node with the given label. Let $v \in V$ be a node and $c \in \Sigma$ be a character. We write $G.\gpred(v, c)$ to denote the set of nodes $u \in V$ such that $G.\glabel(u) = c$ and there is an edge $(u, v) \in E$.

In this paper, we work with de~Bruijn graphs and their generalizations. In order to do so, we need to define collections of (finite or infinite) sequences suitable for constructing \orderk{k} de~Bruijn graphs.

\begin{definition}[\kcollection{k}]
Let $\mathcal{S}$ be a collection of character sequences over alphabet $\Sigma$, and let $k > 0$ be a parameter value. We say that $\mathcal{S}$ is a \emph{\kcollection{k}}, if the collection contains substrings $\#^{k}$ and $\$^{k}$, and each sequence $S \in \mathcal{S}$
(a) is left-infinite or begins with $\#^{k}$;
(b) is right-infinite or ends with $\$^{k}$; and
(c) contains no other occurrences of characters $\#$ and $\$$.
\end{definition}

% FIXME example of strings, DBG, long paths, false positives
\begin{definition}[de~Bruijn graph]
Let $\mathcal{S}$ be a \kcollection{k} over alphabet $\Sigma$. The \orderk{k} \emph{de~Bruijn graph} of $\mathcal{S}$ is a graph $G = (V, E)$ such that
\begin{itemize}
\item each node $v_{X} \in V$ represent a distinct \kmer{k} $X$ occurring in $\mathcal{S}$, with $G.\glabel(v_{X}) = X[0]$;
\item each node $v_{X} \in V$ has a \emph{key} $G.\gkey(v_{X}) = X$; and
\item each edge $(v_{X}, v_{Y}) \in E$ represents a \kmer{k+1} $X[0]Y = Xc$ (where $c \in \Sigma$) occurring in $\mathcal{S}$.
\end{itemize}
We use the node corresponding to $\#^{k}$ as the source node $s$ and the node corresponding to $\$^{k}$ as the sink node $t$, adding the technical edge $(t, s)$ in the usual way.
\end{definition}

De~Bruijn graphs have several properties that make them useful for indexing purposes. Node keys are prefixes of the labels of all paths of length at least $k$ starting from the node. This makes it possible to sort the nodes unambiguosly by path labels. Every substring of the \kcollection{k} is the label of a path in the de~Bruijn graph, and every path label of length at most $k+1$ is a substring of the collection. In Section~\ref{sect:path-indexes}, we develop an index structure based on a generalization of de~Bruijn graphs.

\subsection{Generalized indexes}

Suffix trees, suffix arrays, and \FMindex{} can be generalized to index multiple texts. There are also generalizations for other combinatorial structures. The \emph{XBW transform} \cite{Ferragina2009b} is essentially an \FMindex{} for \emph{labeled trees}. The nodes of the tree are sorted by path labels from the node to the root of the tree. $\BWT$ stores the labels of the children of each node (leaf nodes require special treatment). If a node has $k$ children, we encode that as binary sequence $0^{k-1} 1$. We concatenate these sequences to form bitvector $B$, which is used for mapping lexicographic ranks of nodes to the corresponding BWT ranges. The labels of the children of node $i$ are found in $\BWT[B.\select(i, 1) + 1, B.\select(i + 1, 1)]$.

% FIXME LF(i, c) picture from the slides for the earlier DBG example
The \emph{generalized compressed suffix array} (GCSA) \cite{Siren2014} is a further generalization of the XBW transform for a class of graphs that includes \emph{directed acyclic graphs} and de Bruijn graphs. Before a graph can be indexed, we have to transform it into an equivalent graph, where the nodes can be unambiguously sorted by the labels of the right-maximal paths starting from them. In the worst case, the transformation increases the size of the graph exponentially. After sorting the nodes of the transformed graph in lexicographic order, we encode them using three sequences. $\BWT$ contains the labels of the predecessors, while bitvectors $\bvIN$ and $\bvOUT$ encode the indegrees and outdegrees of each node in the same way as bitvector $B$ of the XBW transform. \LFmapping{} uses $\select$ queries on bitvector $\bvIN$ to map nodes to BWT ranges, ordinary \LFmapping{} with $\BWT$ to map incoming edges to the corresponding outgoing edges, and $\rank$ queries on bitvector $\bvOUT$ to map the outgoing edges to the predecessor nodes.


\section{Path indexes}\label{sect:path-indexes}

A \emph{path index} is a generalization of text indexes for \emph{labeled graphs}. Given a path index for \emph{input graph} $G = (V, E)$, we want to use the index to find the start nodes $v_{0} \in V$ of the paths $P = v_{0} \dotsm v_{\abs{X}-1}$ \emph{matching} the pattern $X$ (paths $P$ with $G.\glabel(P) = X$).

The design of a path index is a trade-off between the maximum supported query length and the size of the index. In the worst case, a graph may have up to $\sigma^{k}$ distinct labels for paths of length $k$ (ignoring the special treatment of characters $\#$ and $\$$), and the length of possible paths is unlimited in cyclic graphs. GCSA \cite{Siren2014} tried to avoid this by considering only a relatively simple class of graphs, using \emph{pruning heuristics} to simplify the graphs when necessary. The price of this was the possibility of \emph{false negatives}: path labels that exist in the graph but not in the index.

\subsection{Basic indexes}

The \emph{\kmer{k} index} is the simplest path index. In its most basic form, the \kmer{k} index consists of a parameter value $k$, a hash function $h$, and an array $A$ of \emph{key-value pairs} $(X, V_{X})$, where $X \in \Sigma^{k}$ and $V_{X} \subseteq V$. Given a \kmer{k} $X \in \Sigma^{k}$, we start looking for key $X$ from $A[h(X)]$, and list the set of start nodes $V_{X}$ as matches if we find it. Searching using a hash table is fast, but we can only search for patterns of length $k$, and the array requires a lot of space.

Another representation of the \kmer{k} index trades query performance for the ability to search for shorter patterns. Instead of using a hash table, we sort the key-value pairs by their keys, and store the pairs in array $A$ in sorted order. Given a pattern $X \in \Sigma^{\ast}$, $\abs{X} \le k$, we use binary search to find the range $A[sp, ep]$ of pairs $(X_{i}, V_{i})$, where pattern $X$ is a prefix of the key $X_{i}$. We then list the union $\bigcup_{i=sp}^{ep} V_{i}$ as the set of matches.

As de~Bruijn graphs and \kmer{k} indexes are both based on \kmer{k}s, we can use one to simulate the other. In order to define the de~Bruijn graph of a graph, we build a \kcollection{k} based on the collection $\mathcal{S}$ of the labels of the maximal paths in graph $G = (V, E)$. If sequence $S \in \mathcal{S}$ is the label of path $P = (v_{i})_{i \in Z}$ in the graph, we set $\mathcal{S}.\gnode(S, i) = v_{i}$ for all positions $i \in Z$. We then transform $\mathcal{S}$ into a \kcollection{k} by inserting the required the number of characters $\#$ to the beginning of each non-left-infinite sequence, and characters $\$$ to the end of each non-right-infinite sequence. If $S[i]$ is a $\#$ we inserted, we set $\mathcal{S}.\gnode(S, i) = (s, j)$, where $s$ is the start node of $G$ and $j$ is the distance to the nearest non-inserted $\#$ in $S$. Similarly, if $S[i]$ is an inserted $\$$, we set $\mathcal{S}.\gnode(S, i) = (t, j)$, where $t$ is the sink node and $j$ is the distance to the nearest non-inserted $\$$.

\begin{definition}[de~Bruijn graph of a graph]
Let $G$ be a labeled graph, and let $\mathcal{S}$ be the \kcollection{k} of maximal path labels in $G$. The \orderk{k} de~Bruijn graph of $\mathcal{S}$ is the \orderk{k} de~Bruijn graph of graph $G$.
\end{definition}

We can use a \kmer{k+1} index of graph $G = (V, E)$ to simulate the \orderk{k} de~Bruijn graph $G' = (V', E')$ of $G$. As the nodes of the de~Bruijn graph correspond to \kmer{k}s and the edges correspond to \kmer{k+1}s, we can represent the nodes by the adjacent edges. If we are interested in node $v \in V'$ with $G'.\gkey(v) = X$, we search for incoming edges $cX$ and outgoing edges $Xc$ for all $c \in \Sigma$. Determining the existence of a node requires $2 \sigma$ queries in the \kmer{k+1} index, and we learn the presence of adjacent nodes and edges in the process.

On the other hand, we can use the \orderk{k} de~Bruijn graph $G' = (V', E')$ of graph $G = (V, E)$ as a \kmer{k} index of $G$ that supports queries of arbitrary length. Let $\mathcal{S}$ be the \kcollection{k} used for building the de~Bruijn graph. For each node $v \in V'$, we attach a set of nodes of graph $G$ as a \emph{value}: $G'.\gvalue(v) = \set{ \mathcal{S}.\gnode(S, i) \mid S \in \mathcal{S}, S[i, i+k-1] = G'.\gkey(v)}.$ Apart from some technicalities near the source/sink nodes, set $G'.\gvalue(v)$ is the set of start nodes of the paths $P$ in graph $G$ with $G.\glabel(P) = G'.\gkey(v)$. Due to the nature of de~Bruijn graphs, this index will not produce any false negatives. There may be \emph{false positives} (path labels that exist in the index but not in the input graph) with patterns longer than $k$, but we can avoid them by \emph{verifying} the results of such queries in the input graph.

\subsection{Path graphs}

De~Bruijn graphs are a special case of path graphs. They represent the paths of length $k$ in the \emph{input graph} as nodes and the pairs of paths overlapping on $k-1$ nodes of the input graph as edges. We can generalize the notion by allowing the nodes of the path graph to represent paths of different lengths.

\begin{definition}[Path graph]
Let $\mathcal{S}$ be a \kcollection{k} of the labels of maximal paths in graph $G = (V, E)$, and let $\mathcal{K}$ be a prefix-free set of strings of length at most $k$ containing $\#^{k}$ and $\$^{k}$. We assume that each right-maximal substring $S$ in $\mathcal{S}$ prefix-matches a string $K \in \mathcal{K}$, and that each string $K \in \mathcal{K}$ is a substring of $\mathcal{S}$. The \orderk{k} \emph{path graph} of graph $G$ with \emph{key set} $\mathcal{K}$ is a graph $G' = (V', E')$ such that
\begin{itemize}
\item each node $v_{K} \in V'$ represent a distinct key $K \in \mathcal{K}$, with $G'.\glabel(v_{K}) = K[0]$;
\item each node has a key $G'.\gkey(v_{K}) = K$ and a value $G'.\gvalue(v_{K}) = V_{K}$, where $V_{K}$ is the set of nodes $\mathcal{S}.\gnode(S, i) \in V$ for $S \in \mathcal{S}$ and positions $i$ such that $S[i, i+\abs{K}-1] = K$; and
\item each edge $(v_{K}, v_{K'}) \in E'$ represents the occurrence of substring $K[0] K'$ in $\mathcal{S}$ such that strings $K$ and $K[0] K'$ prefix-match.
\end{itemize}
We use the node corresponding to $\#^{k}$ as the source node $s$ and the node corresponding to $\$^{k}$ as the sink node $t$, adding the technical edge $(t, s)$ in the usual way.
\end{definition}

\begin{definition}[Path graph as an index]
Let $G = (V, E)$ be a graph, and let $G' = (V', E')$ be a path graph of $G$.
\begin{itemize}
\item Pattern $X \in \Sigma^{\ast}$ \emph{matches} node $v \in V'$, if there is a path $P$ in $G'$ with $G'.\glabel(P) = X$. We use $G'.\find(X)$ to denote the set of nodes $V'_{X} \subseteq V'$ matching the pattern.
\item If $V'_{X} \subseteq V'$ is the set of nodes matching pattern $X$, the set of \emph{occurrences} for the pattern is $G'.\locate(V'_{X}) = G'.\gvalue(V'_{X}) = \bigcup_{v \in V'_{X}} G'.\gvalue(v)$. We use $G'.\locate(X)$ as a shorthand for $G'.\locate(G'.\find(X))$.
\end{itemize}
\end{definition}

\begin{lemma}[No false negatives]\label{lemma:pg-fn}
Let $G' = (V', E')$ be a path graph of graph $G = (V, E)$, and let $X \in \patternset$ be a pattern string. Set $G'.\locate(X)$ contains the start nodes of all paths $P$ in graph $G$ with $G.\glabel(P) = X$.
\end{lemma}

When used as an index, a path graph will not produce false negatives. On the other hand, we may encounter false positives already at path length $k'+1$, where $k'$ is the length of the shortest key in the key set. This is not very convenient for a path index. In the next section, we consider a class of path graphs that can be proven to be equivalent to de~Bruijn graphs.


\subsection{Pruned de Bruijn graphs}

De~Bruijn graphs often have nodes that are redundant when the graph is used as a path index. Removing these nodes from the graph would make the index smaller and more practical. On the other hand, we still want to guarantee that the index works correctly with patterns of length $k$ or less, where $k$ is the order of the de~Bruijn graph.

\begin{definition}[Equivalent path graphs]
Let $G$ and $G'$ be two path graphs, and let $k > 0$ be a parameter value. We say that graphs $G$ and $G'$ are \emph{\kequivalent{k}}, if we have $G.\locate(X) = G'.\locate(X)$ for all patterns $X \in \patternset$ with $1 \le \abs{X} \le k$.
\end{definition}

\begin{definition}[Pruned de~Bruijn graph]
Let $G$ be a graph, and let $G'$ be an \orderk{k} path graph of $G$. Path graph $G'$ is an \orderk{k} \emph{pruned de~Bruijn graph}, if it is \kequivalent{k} to the \orderk{k} de~Bruijn graph of $G$.
\end{definition}

Pruned de~Bruijn graphs are similar to manifold de Bruijn graphs \cite{Lin2014}.

\begin{lemma}[No short false positives]\label{lemma:dbg-fp}
Let $G = (V, G)$ be a graph, let $G' = (V', E')$ be an \orderk{k} pruned de~Bruijn graph of $G$, and let $X \in \patternset$ be a pattern with $1 \le \abs{X} \le k$. Then
(a) $G'.\locate(X)$ is a set of start nodes $v_{0} \in V$ of paths $P$ matching the pattern in graph $G$; and
(b) if $G'$ is a de~Bruijn graph, $X$ is prefix of $G'.\gkey(v'_{0})$ for all $v'_{0} \in G'.\find(X)$.
\end{lemma}

\begin{lemma}[Pruning]\label{lemma:dbg-prune}
Let $G = (V, G)$ be a graph, let $G' = (V', E')$ be the \orderk{k} pruned de~Bruijn graph of $G$ with key set $\mathcal{K}$, let $K \in \Sigma^{\ast}$ be a string of length $\abs{K} > 0$, and let $V'_{K}$ be the set of nodes $v \in V'$ having string $K$ as a prefix of $G'.\gkey(v)$. If $\abs{V'_{K}} > 0$ and $G'.\gvalue(u') = G'.\gvalue(v')$ for all $u, v \in V'_{K}$, the path graph remains an \orderk{k} pruned de~Bruijn graph of $G$, if we remove $G'.\gkey(v)$ for all $v \in V'_{K}$ from the key set and replace them with $K$.
\end{lemma}

De~Bruijn graphs are a special case of pruned de~Bruijn graphs. Hence we may compress a de~Bruijn graph structurally by repeatedly merging sets of nodes sharing a common prefix of their keys, as long as the conditions of Lemma~\ref{lemma:dbg-prune} hold.

\begin{definition}[Maximally pruned de~Bruijn graph]
Let $G'$ be a a pruned de~Bruijn graph of graph $G$ with key set $\mathcal{K}$. We say that $G'$ is \emph{maximally pruned}, if we cannot prune it using Lemma~\ref{lemma:dbg-prune}, and the keys in $\mathcal{K}$ cannot be made shorter without changing the graph structure.
\end{definition}

\begin{lemma}[Maximal pruning]\label{lemma:dbg-maximal}
Let $G' = (V', E')$ be a maximally pruned \orderk{k} de~Bruijn graph. Then
(a) $\abs{G'.\gpred(v', c)} \le 1$ for all nodes $v' \in V'$ and characters $c \in \Sigma$;
(b) $\abs{G'.\gkey(u')} \le \abs{G'.\gkey(v')}+1$ for all nodes $v' \in V'$, characters $c \in \Sigma$, and nodes $u' \in G'.\gpred(v', c)$; and
(c) key $G'.\gkey(v')$ prefix-matches pattern $X \in \patternset$ for all nodes $v' \in G'.\find(X)$.
\end{lemma}


\section{GCSA2}

\subsection{GCSA for path graphs}

Path graphs are essentially equivalent to the prefix-sorted automata, which were used in the original paper on GCSA \cite{Siren2014}. As our technical details are different from the ones used in that paper, we now describe how the GCSA of a path graph works.

% FIXME refer to the figure in Section 2.4
Let $G' = (V', E')$ be a path graph. We sort the nodes $V'$ by their keys in lexicographic order and then process the nodes in that order to generate the sequences $\BWT$, $\bvIN$, and $\bvOUT$. For each node $v' \in V'$, we append
\begin{itemize}
\item $\BWT$ with the predecessor labels $G.\glabel(u')$ for all edges $(u', v') \in E'$;
\item $\bvIN$ with the indegree $x = G.\gindegree(v')$ encoded as a binary sequence $0^{x-1} 1$; and
\item $\bvOUT$ with the outdegree $x = G.\goutdegree(v')$ encoded as a binary sequence $0^{x-1} 1$.
\end{itemize}
If node $v' \in V'$ has lexicographic rank $i$, the range of incoming edges $(u', v') \in E'$ to the node is $[sp_{in}, ep_{in}] = [\bvIN.\select(i, 1) + 1, \bvIN.\select(i+1, 1)]$. The labels of predecessor nodes $u'$ are encoded in $\BWT[sp_{in}, ep_{in}]$. Sorting the incoming edges by pairs $(\BWT[j], i)$, where $\BWT[j]$ corresponds to edge $(u', v')$, is equivalent to sorting them by strings $G'.\glabel(u') \cdot G'.\gkey(v')$. As multiple edges may have the same sort keys, our sorting algorithm must be stable. We get the desired sorting order by using \LFmapping: $j \mapsto \LF(j)$.

Consider now the outgoing edges. If the lexicographic rank of node $u' \in V'$ is $i'$, the range of outgoing edges $(u', v') \in E'$ is $[sp_{out}, ep_{out}] = [\bvOUT.\select(i', 1) + 1, \bvOUT.\select(i'+1, 1)]$. The edges are already sorted by keys $G'.\gkey(u')$. All outgoing edges from the same node have the same sort key, as there is nothing to distinguish them from one another. Because graph $G'$ is a path graph, we know that key $G'.\gkey(u')$ prefix-matches string $G'.\glabel(u') \cdot G'.\gkey(v')$. The sorting orders are therefore compatible. For every $j \in [sp_{in}, ep_{in}]$ for node $v' \in V'$, having $\LF(j) \in [sp_{out}, ep_{out}]$ for node $u' \in V'$ implies an edge $(u', v') \in E'$. If we sort the incoming edges $(u', v') \in E'$ stably by strings $G'.\glabel(u') \cdot G'.\gkey(v')$, we have $(u'_{1}, v'_{1}) < (u'_{2}, v'_{2})$ in that order, if $G'.\gkey(u'_{1}) < G'.\gkey(u'_{2})$.

We implement query $G'.\find(X)$ with \emph{backward searching}. Let $X \in \patternset$ be a pattern. If $\abs{X} = 0$, query $G'.\find(X)$ returns the lexicographic range $[0, \abs{V'}-1]$ containing all nodes of the path graph. Now assume that $\abs{X} \ge 1$ and that query $G'.\find(X[i+1, \abs{X}-1])$ has returned range $[sp_{i+1}, ep_{i+1}]$. We want to find the lexicographic range corresponding to the union of sets $G'.\gpred(v', X[i])$ over nodes $v' \in G'.\find(X[i+1, \abs{X}-1])$. We map the node range $[sp_{i+1}, ep_{i+1}]$ to range $[sp_{in}, ep_{in}]$ of incoming edges (with $sp_{in} = 0$ if $sp_{i+1} = 0$); the incoming edges to the corresponding range of outgoing edges $[sp_{out}, ep_{out}]$; and the outgoing edges to the range $[sp_{i}, ep_{i}]$ of nodes $G'.\find(X[i, \abs{X}-1])$:
\begin{align*}
[sp_{in}, ep_{in}] & = [\bvIN.\select(sp_{i+1}, 1) + 1, \bvIN.\select(ep_{i+1}+1, 1)]; \\
[sp_{out}, ep_{out}] & = [\LF(sp_{in}, X[i]), \LF(ep_{in}+1, out) - 1];\ \textrm{and} \\
[sp_{i}, ep_{i}] & = [\bvOUT.\rank(sp_{out}, 1), \bvOUT.\rank(ep_{out}, 1)].
\end{align*}
We can think this as a generalization of \LFmapping: $[sp_{i}, ep_{i}] = G'.\LF([sp_{i+1}, ep_{i}], X[i])$.

Query $G'.\locate(X)$ requires retrieving the values $G'.\gvalue(v')$ for nodes $v' \in V'$ in the lexicographic range returned by query $G'.\find(X)$. Storing the values explicitly for all nodes would make the path index several times larger than the graph structure described above. To avoid that, GCSA uses a similar \emph{sampling} scheme to the one used in FM-indexes. We assume that the nodes $v \in V$ of the input graph $G = (V, E)$ are integers, and that the node numbering has been chosen with our sampling scheme in mind. If $(u, v) \in E$ is the only outgoing edge from node $u$ and the only incoming edge to node $v$, it should be that $v = u+1$.

Let $v' \in V'$ be a node of the path graph. We sample the values $G'.\gvalue(v')$, (a) if there are multiple incoming edges to node $v'$; (b) if $v'$ is the source node $s$; or (c) if $(u', v') \in E'$ is the only incoming edge to node $v'$, and $G'.\gvalue(v') \ne \set{u+1 \mid u \in G'.\gvalue(u')}$. We may also sample the values for some nodes on long unary paths for performance reasons. If the values $G'.\gvalue(v')$ has not been sampled, we can derive them from sampled values by following the incoming edges backwards.

Following edges backwards is based on a similar generalization of \LFmapping{} as backward searching. If node $v' \in V'$ has lexicographic rank $i$, the lexicographic rank of its only predecessor is
$G'.\LF(i) = \bvOUT.\rank(\LF(\bvIN.\select(i, 1) + 1), 1)$. If lexicographic rank $G'.\LF^{k}(i)$ corresponding to node $w' \in V'$ is the first sampled node we encounter, we know that $G'.\gvalue(v') = \set{w+k \mid w \in G'.\gvalue(w')}$.

Let $B_{S}[0, \abs{V'}-1]$ be a bitvector marking the sampled nodes. If we have sampled the values for the node $v' \in V'$ with lexicographic rank $i$, we mark that as $B_{S} = 1$. We can then determine the rank of node $v'$ among the sampled nodes as $j = B_{S}.\rank(i, 1)$. For each sampled node $v' \in V$, we store the size of the value set $\abs{G'.\gvalue(v')}$ in another bitvector $B_{V}$, using the same encoding as in bitvectors $\bvIN$ and $\bvOUT$. We then store the samples in array $V_{S}$ in the same order, using $\log \abs{V}$ bits each. The sampled values for node $v'$ with rank $j$ among the sampled nodes can be found at $V_{S}[B_{V}.\select(j, 1) + 1, B_{V}.\select(j+1, 1)]$.

If $G'.\gpred(v', c) \le 1$ for all nodes $v' \in V'$ and characters $c \in \Sigma$, such as in de~Bruijn graphs and maximally pruned de~Bruijn graphs, we can use a simplified encoding for the graph \cite{Siren2014}. We replace sequences $\BWT$ and $\bvIN$ with \emph{indicator bitvectors} $B_{c}[0, \abs{V'}-1]$ for all $c \in \Sigma$. If node $v' \in V$ has a predecessor with label $c \in \Sigma$, we set$B_{c}[i] = 1$. Backward searching is now simpler: $[sp_{i}, ep_{i}] = [G'.\LF(sp_{i+1}, c), G'.\LF(ep_{i+1}+1, c) - 1]$, where
$$
G'.\LF(i, c) = \bvOUT.\rank(C[c] + B_{c}.\rank(i, 1), 1).
$$
We replace two expensive queries ($\bvIN.\select()$ and $\BWT.\rank()$) with a single $\rank$ query on a bitvector. On the other hand, computing $G'.\LF()$ is now more expensive, as we have to look at $B_{c}[i]$ for all $c \in \Sigma$ to determine $\BWT[i]$. The alternative is to follow outgoing edges when searching for samples; this requires two $\select$ queries per edge.

\subsection{Index construction}

Prefix-doubling; k to 2k, 4k, 8k. original GCSA did not have to store labels, as it built an unlimited order graph

prune, extend, full prune, merge

paths: start, extension, predecessors, key; encode key as a sequence of kmer ranks

prune: only if start node is the same; full prune as before

extend: join when extension matches start; do not extend if already pruned; if right side is pruned, the extended path is also pruned

merge: invariant: path labels are the key set of a pruned de Bruijn graph; full pruning produces a maximally pruned graph

disk-based: each chromosome in a separate file sorted by keys; extend by file; prune/merge essentially merge sorted lists

edges and construction: use \LFmapping{} in GCSA of the de~Bruijn graph of the kmers to determine the rank sequence of $c \cdot G'.\gkey(v')$; need $\sigma + 1$ sequential pointers in each file

\subsection{Extensions}

These are both based on ST, which requires a maximally pruned DBG

count()
- SadaCount \cite{Sadakane2007a}
- compressible \cite{Gagie2015}

parent()
- CST-NPR: \cite{Fischer2009a}
- CST MEMs: \cite{Ohlebusch2010a}
- used for MEM mapping: \cite{Li2013}

\section{Experiments}


\section{Discussion}


% FIXME
\subparagraph*{Acknowledgements.}

I thank Richard Durbin, Erik Garrison, and Adam Novak for \dots


\bibliography{paper}


\clearpage
\appendix
\section{Proofs of lemmas}

\begin{proof}[Proof of Lemma~\ref{lemma:pg-fn} (No false negatives)]
Let $\mathcal{S}$ be the \kcollection{k} used for building the path graph, and let $P$ be a path starting from node $v_{0} \in V$ with $G.\glabel(P) = X$. The collection contains a sequence $S \in \mathcal{S}$ such that $S[i, i+\abs{X}-1] = X$ and $\mathcal{S}.\gnode(S, i) = v_{0}$.

For all positions $j$ with $i \le j < i+\abs{X}$, there is a node $v'_{j} \in V'$ with $G'.\glabel(v'_{j}) = S[j]$ and $G'.\gkey(v'_{j}) = S[j, j+\abs{G'.\gkey(v'_{j})}-1]$.
By definition, the path graph has an edge $(v'_{j}, v'_{j+1}) \in E'$ for $i \le j < i+\abs{X}-1$.
Hence $P' = v'_{i} \dotsm v'_{i+\abs{X}-1}$ is a path in $G'$ with $G'.\glabel(P') = X$.
As path $P'$ starts from node $v'_{i} \in V'$, node $v'_{i}$ is included in the set $G'.\find(X)$.
Furthermore, $v_{0} = \mathcal{S}.\gnode(S, i) \in G'.\gvalue(v'_{i}) \subseteq G'.\locate(X)$.
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lemma:dbg-fp} (No short false positives)]
If (a) holds for de~Bruijn graphs, it also holds for pruned de~Bruijn graphs. From now on, let $G'$ be a de~Bruijn graph, and let $\mathcal(S)$ be the \kcollection{k} used for building graph $G'$.

(b) If $\abs{X} = 1$, the statement is true by definition. Now let $\abs{X} \ge 2$, and let $P' = v'_{0} \dotsm v'_{\abs{X}}$ be a path matching $X$ in graph $G'$. Every edge $(v'_{i}, v'_{i+1}) \in E'$ corresponds to a substring $S_{i}[j, j+k] = X[i] \cdot G'.\gkey(v'_{i+1})$ in $\mathcal{S}$, and the substring has $G'.\gkey(v'_{i})$ as a prefix. By induction from $\abs{X}-2$ to $0$, substring $S_{i}[j, j+k]$ has $X[i, \abs{X}-1]$ as a prefix.

(a) Now let $S[i, i+k-1] = G'.\gkey(v'_{0})$ be a substring of $\mathcal{S}$, where $v'_{0} \in G'.\find(X)$. Every node $v \in G'.\gvalue(v'_{0})$ is the node $\mathcal{S}.\gnode(S, i)$ for one of such substrings. By (b), $S[i, i+\abs{X}-1] = X$, which corresponds to a path $P$ matching $X$ in graph $G$, with $\mathcal{S}.\gnode(S, i)$ as the start node.
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lemma:dbg-prune} (Pruning)]
Let $G_{d} = (V_{d}, E_{d})$ be the \orderk{k} de~Bruijn graph of $G$, let $G'' = (V'', E'')$ be the path graph corresponding to the new key set, and let $\mathcal{S}$ be the \kcollection{k} used for building the path graphs. Each node $v'' \in V''$ is an equivalence class of nodes $V_{d}(v'') \subseteq V_{d}$ corresponding to a shared prefix $G''.\gkey(v'')$ of keys. For all $v \in V_{d}(v'')$, we have $G_{d}.\gvalue(v) = G''.\gvalue(v'')$.

Let $X \in \patternset$ be a pattern with $1 \le \abs{X} \le k$, and let $S[i, i+k-1] = G_{d}.\gkey(v_{0})$ be a substring of $\mathcal{S}$, where $v_{0} \in G_{d}.\find(X)$. By Lemma~\ref{lemma:dbg-fp}, $X$ is a prefix of the substring. We extend the substring to length $\abs{X}+k-1$ without changing its starting position. The extended substring $S[i, i+\abs{X}+k-2]$ corresponds to a path $P = v_{0} \dotsm v_{\abs{X}}$ with label $X$ in the de~Bruijn graph, with $G_{d}.\gkey(v_{j}) = S[i+j, i+j+k-1]$. If we change each node $v_{j}$ to the corresponding equivalence class $v''_{j} \in V''$, we get a path with label $X$ in graph $G''$.

Now let $P'' = v''_{0} \dotsm v''_{\abs{X}-1}$ be a path matching pattern $X$ in graph $G''$. If $\abs{X} = 1$, we can choose any $v_{0} \in V_{d}(v''_{0})$. Now assume that we have chosen node $v_{j+1}$ from the equivalence class $V_{d}(v''_{j+1})$ and that $X[j+1, \abs{X}-1]$ is a prefix of $G_{d}.\gkey(v_{j+1})$. As edge $(v''_{j}, v''_{j+1}) \in E''$ exists, it must be that $\abs{G.\gpred(v, X[j])} > 0$ for a node $v \in G''.\gvalue(v''_{j+1}) = G_{d}.\gvalue(v_{j+1})$. Therefore substring $X[j] \cdot G_{d}.\gkey(v_{j+1})$ exists in $\mathcal{S}$, and the node $v_{j} \in V_{d}$ with $G_{d}.\gkey(v_{j}) = (X[j] \cdot G_{d}.\gkey(v_{j+1}))[0, k-1]$ has $X[j, \abs{X}-1]$ as a prefix of its key. As $G''.\gkey(v''_{j})$ is a prefix of $X[j] \cdot G''.\gkey(v''_{j+1})$, which is a prefix of $X[j] \cdot G_{d}.\gkey(v_{j+1})$, key $G''.\gkey(v''_{j})$ is also a prefix of $G_{d}.\gkey(v_{j})$, and hence $v_{j} \in V_{d}(v''_{j})$. When $j = 0$, we can extend the substring as above to get a path matching the pattern in $G_{d}$, with $v_{0}$ as the start node.

Given $v_{0} \in G_{d}.\find(X)$, we can build a path $P'' = v''_{0} \dotsm v''_{\abs{X}-1}$ matching the pattern in graph $G''$, with $v_{0} \in V_{d}(v''_{0})$. We can also start from path $P''$ and determine the node $v_{0}$. As $G_{d}.\gvalue(v_{0}) = G''.\gvalue(v''_{0})$, we have $G_{d}.\locate(X) = G''.\locate(X)$.
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lemma:dbg-maximal} (Maximal pruning)]
(a) The key $G.\gkey(u')$ of a node $u' \in G'.\gpred(v', c)$ prefix-matches string $c \cdot G.\gkey(v')$. If $\abs{G'.\gpred(v', c)} > 1$, the keys must be longer than string $c \cdot G.\gkey(v)$ in order to be distinct. In that case, there cannot be an edge $(u', w')$ to another node $w' \ne v'$, as the keys $G.\gkey(v')$ and $G.\gkey(w')$ would prefix-match. Hence $G'.\gvalue(u')$ must be the union of sets $G.\gpred(v, c)$ over nodes $v \in G'.\gvalue(v')$, and we can merge the set $G'.\gpred(v', c)$ into a single node. Because graph $G'$ is already maximally pruned, it must be that $\abs{G'.\gpred(v', c)} \le 1$.

(b) Assume that $\abs{G'.\gkey(u')} > \abs{G'.\gkey(v')}+1$. Key $G'.\gkey(u')$ must have $c \cdot G'.\gkey(v')$ as a prefix. If there is a substring $S[i,j] = c \cdot G'.\gkey(v')$ in the \kcollection{k} used for building graph $G'$, the key starting at $S[i]$ must belong to a node in $G'.\gpred(v', c)$. By (a), $u'$ is the only such node, and hence string $c \cdot G'.\gkey(v')$ can also serve as its key.

(c) If $\abs{X} = 0$, every key prefix-matches the pattern. If $\abs{X} = 1$, set $G'.\find(X)$ is the set of nodes $v' \in V'$ with $G'.\glabel(v') = X[0]$. Now assume that $\abs{X} \ge 2$ and that $G'.\gkey(v')$ prefix-matches $X[1, \abs{X}-1]$ for all $v' \in G'.\find(X[1, \abs{X}-1])$. By (a), there is at most one node $u' \in G'.\gpred(v', X[0])$ for each such node $v'$. By (b), key $G'.\gkey(u')$ is a prefix of $X[0] \cdot G'.\gkey(v')$. Because $X[1, \abs{X}-1]$ prefix-matches $G'.\gkey(v')$, pattern $X$ prefix-matches string $X[0] \cdot G'.\gkey(v')$, and hence the pattern must prefix-match key $G'.\gkey(u')$.
\end{proof}


\end{document}
