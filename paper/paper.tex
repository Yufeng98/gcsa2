\documentclass[a4paper,UKenglish]{lipics-v2016}

\usepackage{microtype}

\bibliographystyle{plainurl}

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Indexing Variation Graphs\footnote{This work was supported by the Wellcome Trust grant [098051].}}

\author[1]{Jouni Sirén}
\affil[1]{Wellcome Trust Sanger Institute, Hinxton, Cambridge, UK\\
  \texttt{jouni.siren@iki.fi}}
\authorrunning{J. Sirén}

\Copyright{Jouni Sirén}

\subjclass{E.1 Data Structures}
\keywords{Burrows-Wheeler transform, de Bruijn graphs, path indexes, variation graphs}
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Mathematics
\newcommand{\set}[1]{\ensuremath{\{ #1 \}}}
\newcommand{\abs}[1]{\ensuremath{\lvert #1 \rvert}}
\newcommand{\Oh}[1]{\ensuremath{\mathsf{O}\!\left( #1 \right)}}

% DNA
\newcommand{\dnaseq}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\baseA}{\dnaseq{A}}
\newcommand{\baseC}{\dnaseq{C}}
\newcommand{\baseG}{\dnaseq{G}}
\newcommand{\baseT}{\dnaseq{T}}
\newcommand{\baseN}{\dnaseq{N}}
\newcommand{\dnacomp}[1]{\ensuremath{\overline{#1}}}
\newcommand{\revcomp}[1]{\ensuremath{\overleftarrow{#1}}}

% Queries
\newcommand{\rank}{\ensuremath{\mathsf{rank}}}
\newcommand{\select}{\ensuremath{\mathsf{select}}}
\newcommand{\LF}{\ensuremath{\mathsf{LF}}}
\newcommand{\find}{\ensuremath{\mathsf{find}}}
\newcommand{\locate}{\ensuremath{\mathsf{locate}}}
\newcommand{\parent}{\ensuremath{\mathsf{parent}}}
\newcommand{\countq}{\ensuremath{\mathsf{count}}}

% Graphs
\newcommand{\gindegree}{\ensuremath{\mathsf{in}}}
\newcommand{\goutdegree}{\ensuremath{\mathsf{out}}}
\newcommand{\glabel}{\ensuremath{\mathsf{label}}}
\newcommand{\gpred}{\ensuremath{\mathsf{pred}}}
\newcommand{\gkey}{\ensuremath{\mathsf{key}}}
\newcommand{\gvalue}{\ensuremath{\mathsf{value}}}
\newcommand{\gnode}{\ensuremath{\mathsf{node}}}
\newcommand{\gext}{\ensuremath{\mathsf{ext}}}

% Shorthands
\newcommand{\kmer}[1]{$#1$\nobreakdash-mer}
\newcommand{\kcollection}[1]{$#1$\nobreakdash-collection}
\newcommand{\kequivalent}[1]{$#1$\nobreakdash-equivalent}
\newcommand{\orderk}[1]{order\nobreakdash-$#1$}
\newcommand{\LFmapping}{LF\nobreakdash-mapping}
\newcommand{\FMindex}{FM\nobreakdash-index}
\newcommand{\patternset}{\ensuremath{(\Sigma \setminus \set{\#, \$})^{\ast}}}

% Structures
\newcommand{\SA}{\ensuremath{\mathsf{SA}}}
\newcommand{\BWT}{\ensuremath{\mathsf{BWT}}}
\newcommand{\Carray}{\ensuremath{\mathsf{C}}}
\newcommand{\LCP}{\ensuremath{\mathsf{LCP}}}
\newcommand{\bvIN}{\ensuremath{\mathsf{IN}}}
\newcommand{\bvOUT}{\ensuremath{\mathsf{OUT}}}


\begin{document}

\maketitle

\begin{abstract}
Variation graphs, which represent genetic variation within a population, are replacing sequences as reference genomes. Path indexes are one of the most important tools for working with variation graphs. They generalize text indexes for graphs, allowing one to find the paths matching the query string. We propose using pruned de Bruijn graphs as path indexes, and encode them space-efficiently with the Burrows-Wheeler transform. We also generalize many ideas from text indexing literature to work with graphs. The proposed approach has been implemented in the variation graph toolkit vg.
\end{abstract}


\section{Introduction}

Sequencing pipelines typically start with mapping the reads from the sequenced genome to a \emph{reference genome} of the same species. As reference genomes are usually assembled from the genomes of a small number of individuals, they are biased towards those individuals. This \emph{reference bias} may affect the results of subsequent analysis, especially when the sequenced individuals are from different populations than the ones behind the reference genome.

Recently there has been much interest in \emph{variation graphs} (also called pan-genomes, graph genomes, or reference graphs), which encode the genetic variation within a population as a graph \cite{Paten2014,Marcus2014,Church2015,Dilthey2015,Marschall2016}. These graphs are eventually expected to replace reference sequences as reference genomes. The shift to graph references will likely take years, as new methods and tools must be developed to replace those based on linear references.

The \emph{variation graph toolkit vg} \cite{Garrison2014-2016} is a community effort to develop such tools. This paper describes \emph{GCSA2}, the path index developed for vg. A \emph{path index} is a generalization of text indexes for labeled graphs. They are used for finding paths with labels that match the query string. Indexing graphs for path queries is an inherently hard problem, as the number of paths increases exponentially with path length. Hence the design of a path index is a trade-off between maximum supported query length, the size of the index, and pruning complex regions of the graph before indexing.

Mapping reads to a graph was first investigated by Schneeberger et~al.~\cite{Schneeberger2009}. Sirén et~al.~\cite{Siren2014} developed \emph{GCSA}, which generalized the FM\nobreakdash-index \cite{Ferragina2005a} from a text index to a path index. The original GCSA could only index directed acyclic graphs and depended on pruning the complex regions, as it did not place any limits on query length. Kim et~al.~\cite{Kim2015-2016} combined GCSA with the ideas developed for the HISAT read aligner \cite{Kim2015}. The resulting HISAT2 aligner was the first practical graph-based read aligner, though it only uses the graph for more accurate mapping to a linear reference.

The \emph{succinct de~Bruijn graphs} of Bowe et.~al.~\cite{Bowe2012} used a similar generalization of the FM\nobreakdash-index as in GCSA for representing \emph{de~Bruijn graphs} space-efficiently. Rødland \cite{Roedland2013} proposed another similar generalization. The succinct de~Bruijn graphs have been generalized to represent \orderk{k} de~Bruijn graphs with different values of $k$ in the same structure \cite{Boucher2014}, but they still need to store the graph for the largest value of $k$ explicitly. Compacted \cite{Cazaux2014} and compressed de~Bruijn graphs \cite{Marcus2014} achieve similar space savings by representing unary paths in the graph as a single node. A prototype read aligner based on compacted de~Bruijn graphs has been proposed \cite{Limasset2015}.

Other approaches to indexing variation graphs include BWBBLE \cite{Huang2013}, which indexes the graph as a collection of sequences. Simple variants are encoded by using the powerset alphabet, while more complex variants are represented as separate sequences, with a sufficient amount of context around the variant site. This is usually enough to keep the index small, at the price of much higher query times. The hypertext index \cite{Thachuk2013} is another similar idea. The nodes of the graph are labeled with strings, which are indexed using an ordinary FM-index. Partial matches in the strings are combined into full matches with range queries in the edge matrix. While matches crossing one edge are easy to find, the approach becomes complex and potentially slow with matches crossing multiple edges. There are also several indexes (e.g.~\cite{Huang2010,Wandelt2013,Danek2014,Na2015}), which use a graph as a space-efficient representation for similar sequences but index the sequences instead of the graph.

GCSA2 combines ideas from the original GCSA and from succinct de~Bruijn graphs. Conceptually it uses a de~Bruijn graph as a path index of a variation graph. The \orderk{k} de~Bruijn graph is \emph{pruned} (compressed structurally) by using strings shorter than $k$ characters as nodes, if the shorter strings identify the start nodes of the corresponding paths uniquely. The pruned graph is then encoded with a generalization of the FM\nobreakdash-index. GCSA2 includes novel extensions based on what is essentially a suffix tree of the pruned de~Bruijn graph. These extensions are used for e.g.~finding maximal exact matches in the vg read aligner.

This paper contains several lemmas describing the properties of generalizations of de~Bruijn graphs. Their proofs are included in Appendix~\ref{appendix:proofs}.


\section{Background}

\subsection{Strings}\label{sect:strings}

A \emph{string} $S[0, n-1] = s_{0} \dotsm s_{n-1}$ of length $\abs{S} = n$ is a sequence of \emph{characters} over an \emph{alphabet} $\Sigma = \set{0, \dotsc, \sigma - 1}$. For indexing purposes, we often consider \emph{text} strings $T[0, n-1]$ terminated by an \emph{endmarker} $T[n-1] = \$ = 0$ not found anywhere else in the text. \emph{Binary} sequences are strings over the alphabet $\set{0, 1}$. A \emph{substring} of string $S$ is a sequence of the form $S[i, j] = s_{i} \dotsm s_{j}$. We call substrings of the type $S[0, j]$ and $S[i, n-1]$ \emph{prefixes} and \emph{suffixes}, respectively, and substrings of length $k$ as \kmer{k}s. Substring $S[i, j]$ is a \emph{proper} substring of string $S$, if $S \ne S[i, j]$. We say that string $S'$ is a substring of string collection $\mathcal{S}$, if there is a string $S \in \mathcal{S}$ such that $S'$ is a substring of $S$.

Sometimes we consider \emph{infinite} character sequences $S = (s_{i})_{i \in Z}$, where set $Z$ is a contiguous infinite subset of $\mathbb{Z}$. The notion of substrings generalizes for such infinite sequences in a natural way. We say that a substring of an infinite sequence $S$ is \emph{left-infinite} if it extends infinitely to the left, and \emph{right-infinite} if it extends infinitely to the right. A substring of a finite or infinite sequence $S$ is \emph{left-maximal} if it is left-infinite or a prefix; \emph{right-maximal} if it is right-infinite or a suffix; and \emph{maximal} if it is both left-maximal and right-maximal.

We primarily consider sequences over the \emph{DNA} alphabet $\set{\$, \baseA, \baseC, \baseG, \baseT, \baseN}$. Characters $\baseA$, $\baseC$, $\baseG$, and $\baseT$ are called \emph{bases}, while character $\baseN$ represents an arbitrary or unknown base. In addition to the endmarker $\$$, the alphabet may also contain other characters for technical purposes. Each character $c$ of the DNA alphabet has a \emph{complement} $\dnacomp{c}$ defined as $\dnacomp{\baseA} = \baseT$, $\dnacomp{\baseC} = \baseG$, $\dnacomp{\baseG} = \baseC$, $\dnacomp{\baseT} = \baseA$, and $\dnacomp{c} = c$ for other characters $c$. Given a DNA sequence $S$, its \emph{reverse complement} is the sequence $\revcomp{S}$ obtained by reversing the non-technical parts of the sequence and replacing each character with its complement. For example, $\revcomp{\dnaseq{GATTACA}\$} = \dnaseq{TGTAATC}\$$.

Given string $S[0, n-1]$, we define $S.\rank(i, c)$ to be the number of occurrences of character $c$ in the prefix $S[0, i-1]$. We also define $S.\select(i, c) = \arg \max_{j \le n} S.\rank(j, c) < i$ as the position of the occurrence of character $c$ with rank $i > 0$.\footnote{These definitions are used in the SDSL library \cite{Gog2014b}. We assume for convenience that $S.\select(0, c) = -1$.} A \emph{bitvector} is a binary sequence supporting efficient $\rank$/$\select$ queries. \emph{Wavelet trees} \cite{Grossi2003} are space-efficient data structures that use bitvectors to support $\rank$/$\select$ queries on arbitrary strings.

Let $S$ be a string and $S'$ be be a string or an infinite character sequence over alphabet $\Sigma$. We say that sequences $S$ and $S'$ \emph{prefix-match}, if $S$ is a prefix of $S'$ or $S'$ is a prefix of $S$. Set $\mathcal{S}$ of strings is \emph{prefix-free}, if no two strings $S, S' \in \mathcal{S}$ (with $S \ne S'$) prefix-match.

\subsection{Text indexes}

The \emph{suffix tree} \cite{Weiner1973} is the most fundamental full-text index supporting substring queries. It is formed by taking the suffixes of the text, storing them in a trie, and compacting unary paths in the trie into single edges. If $v$ is a node of a suffix tree, we write $\ell(v)$ to denote the label of the path from the root to node $v$. Although fast and versatile, suffix trees are only of limited use in indexing large texts, as they require much more space than the text itself.

\emph{Suffix arrays} \cite{Manber1993} were introduced as a space-efficient alternative to the suffix tree. The suffix array of text $T[0, n-1]$ is an array of pointers $\SA[0, n-1]$ to the suffixes of the text in \emph{lexicographic order}. Given a text and its suffix array, we can find the occurrences of \emph{pattern} string $X$ in the text by using \emph{binary search} in $\Oh{\abs{X} \log n}$ time. The suffix array requires $n \log n$ bits of space in addition to the $n \log \sigma$ bits used by the text --- still much more than the text --- while its functionality is more limited than that of the suffix tree. See Figure~\ref{figure:indexes} for an example of the suffix array and related structures.

\begin{figure}[t!]
\includegraphics{gcsa2_text_indexes.pdf}
\caption{\LFmapping, BWT, suffix array, and LCP array for text $\dnaseq{GCATCATA}\$$.}\label{figure:indexes}
\end{figure}

The \emph{Burrows-Wheeler transform (BWT)} \cite{Burrows1994} is a permutation of the text with the same combinatorial structure as the suffix array. Given text $T[0, n-1]$, its Burrows-Wheeler transform is a string $\BWT[0, n-1]$, where $\BWT[i] = T[(\SA[i]-1) \bmod n]$. Given the \emph{lexicographic rank} $i$ of suffix $T[\SA[i], n-1]$, we can use \emph{\LFmapping} on the BWT to find the lexicographic rank of the previous suffix $T[(\SA[i]-1) \bmod n, n-1]$. Let
$$
\LF(i) = \Carray[\BWT[i]] + \BWT.\rank(i, \BWT[i]),
$$
where $\Carray[c]$ is the number of occurrences of characters $c' < c$ in the BWT. Then $\SA[\LF(i)] = (\SA[i]-1) \bmod n$. We can also generalize the definition for any character $c \in \Sigma$:
$$
\LF(i, c) = \Carray[c] + \BWT.\rank(i, c).
$$
Let $X$ be a string. If there are $i$ suffixes $S'$ of text $T$ such that $S' < X$ in lexicographic order, then there are $\LF(i, c)$ suffixes smaller than string $cX$ in lexicographic order.

Given the similarities to the suffix array, we can use the BWT as a space-efficient text index. The \emph{\FMindex} \cite{Ferragina2005a} combines a plain or compressed representation of the BWT supporting $\rank$/$\select$ queries, the $\Carray$ array, and a set of \emph{sampled pointers} from the suffix array. It finds the \emph{lexicographic range} of suffixes matching pattern $X$ (having $X$ as a prefix) with a process called \emph{backward searching}. If the lexicographic range matching suffix $X[i+1, \abs{X}-1]$ of the pattern is $\SA[sp, ep]$, then the lexicographic range matching suffix $X[i, \abs{X}-1]$ of the pattern is $\SA[\LF(sp, X[i]), \LF(ep+1, X[i]) - 1]$. Finding the lexicographic range matching the entire pattern requires $\Oh{\abs{X}}$ rank queries.

We can use the sampled suffix array pointers to find the text positions containing the occurrences. If $\SA[i]$ is not sampled, we start iterating $\LF(i)$, until we find a sampled pointer. If we find a sample at $\SA[\LF^{k}(i)]$, we know that
$$
\SA[i] = (\SA[\LF^{k}(i)] + k) \bmod n.
$$
If we have sampled one out of $d$ suffix array pointers at regular intervals, finding each occurrence takes $\Oh{d}$ rank queries. If we also sample one out of $d'$ \emph{inverse suffix array} pointers\footnote{The suffix array is a permutation of $\set{0, \dotsc, n-1}$, and the inverse suffix array is the inverse permutation.}, we can \emph{extract} an arbitrary substring $X$ of the text using $\Oh{\abs{X}+d'}$ rank queries.

The \emph{longest-common-prefix array} (LCP array) \cite{Manber1993} is an integer array $\LCP[0, n-1]$, where each value $\LCP[i]$ tells the length of the longest common prefix of suffixes $T[\SA[i-1], n-1]$ and $T[\SA[i], n-1]$ (with $\LCP[0] = 0$). It is often used to augment the functionality of the suffix array and the \FMindex. In particular, if we augment the \FMindex{} with the LCP array and the topology of the suffix tree, we get the \emph{compressed suffix tree}, which supports the full functionality of the suffix tree in a space-efficient manner \cite{Sadakane2007}.

\subsection{Graphs}\label{sect:graphs}

A \emph{graph} $G = (V, E)$ consists of a set of \emph{nodes} $V = \set{0, \dotsc, \abs{V}-1}$ and a set of \emph{edges} $E \subseteq V \times V$. We say that $(u, v) \in E$ is an edge \emph{from} node $u$ \emph{to} node $v$, and assume that the edges are \emph{directed}: $(u, v) \ne (v, u)$ for $u \ne v$. The \emph{indegree} $G.\gindegree(v)$ of node $v$ is the number of \emph{incoming} edges to $v$, while the \emph{outdegree} $G.\goutdegree(v)$ is the number of \emph{outgoing} edges from $v$.

The graphs we consider are \emph{labeled} with alphabet $\Sigma$: each node $v \in V$ has a \emph{label} $G.\glabel(v) \in \Sigma$. A \emph{path} in a graph is a sequence of nodes $P = v_{0} \dotsm v_{\abs{P}-1}$ such that $(v_{i}, v_{i+1}) \in E$ for all $i, i+1 \in \set{0, \dotsc, \abs{P}-1}$. We say that $v_{0}$ is the \emph{start} node and $v_{\abs{P}-1}$ is the \emph{end} node of the path. The label of a path is the concatenation of node labels $G.\glabel(P) = G.\glabel(v_{0}) \dotsm G.\glabel(v_{\abs{P}-1})$.

We generalize the definition for infinite paths $P = (v_{i})_{i \in Z}$ in a similar way as we did with infinite character sequences in Section~\ref{sect:strings}. We say that path $P$ is \emph{left-maximal} if it starts at the source node or extends infinitely to the left; \emph{right-maximal} if it ends at the sink node or extends infinitely to the right; and \emph{maximal} if it is both left-maximal and right-maximal.

We assume for convenience that all graphs have two special nodes: the \emph{source} node $s$ and the \emph{sink} node $t$. To distinguish them from the other nodes, we label them with characters $G.\glabel(s) = \#$ and $G.\glabel(t) = \$$. The label of the sink node is unique in the graph, while the label of the source node can be used in other nodes for technical purposes. We add an edge $(s, v)$ for all nodes $v \in V \setminus \set{s}$ that have no other incoming edges, and an edge $(v, t)$ for all nodes $v \in V \setminus \set{t}$ with no other outgoing edges. We also add edge $(t, s)$ to guarantee that $G.\gindegree(v) \ge 1$ and $G.\goutdegree(v) \ge 1$ for all nodes $v \in V$. However, this edge is not considered a real edge, and no path can cross it.

Given a graph $G = (V, E)$, we may want to reason about the \emph{predecessors} of a node with the given label. Let $v \in V$ be a node and $c \in \Sigma$ be a character. We write $G.\gpred(v, c)$ to denote the set of nodes $u \in V$ such that $G.\glabel(u) = c$ and there is an edge $(u, v) \in E$.

In this paper, we work with de~Bruijn graphs and their generalizations. In order to do so, we need to define collections of (finite or infinite) sequences suitable for constructing \orderk{k} de~Bruijn graphs.

\begin{definition}[\kcollection{k}]
Let $\mathcal{S}$ be a collection of character sequences over alphabet $\Sigma$, and let $k > 0$ be a parameter value. We say that $\mathcal{S}$ is a \emph{\kcollection{k}}, if the collection contains substrings $\#^{k}$ and $\$^{k}$, and each sequence $S \in \mathcal{S}$
(a) is left-infinite or begins with $\#^{k}$;
(b) is right-infinite or ends with $\$^{k}$; and
(c) contains no other occurrences of characters $\#$ and $\$$.
\end{definition}

\begin{definition}[de~Bruijn graph]
Let $\mathcal{S}$ be a \kcollection{k} over alphabet $\Sigma$. The \orderk{k} \emph{de~Bruijn graph} of $\mathcal{S}$ is a graph $G = (V, E)$ such that
\begin{itemize}
\item each node $v_{X} \in V$ represent a distinct \kmer{k} $X$ occurring in $\mathcal{S}$, with $G.\glabel(v_{X}) = X[0]$;
\item each node $v_{X} \in V$ has a \emph{key} $G.\gkey(v_{X}) = X$; and
\item each edge $(v_{X}, v_{Y}) \in E$ represents a \kmer{k+1} $X[0]Y = Xc$ (where $c \in \Sigma$) occurring in $\mathcal{S}$.
\end{itemize}
We use the node corresponding to $\#^{k}$ as the source node $s$ and the node corresponding to $\$^{k}$ as the sink node $t$, adding the technical edge $(t, s)$ in the usual way.
\end{definition}

De~Bruijn graphs have several properties that make them useful for indexing purposes. Node keys are prefixes of the labels of all paths of length at least $k$ starting from the node. This makes it possible to sort the nodes unambiguously by path labels. Every substring of the \kcollection{k} is the label of a path in the de~Bruijn graph, and every path label of length at most $k+1$ is a substring of the collection. In Section~\ref{sect:path-indexes}, we develop an index structure based on a generalization of de~Bruijn graphs.

\subsection{Generalized indexes}

Suffix trees, suffix arrays, and \FMindex{} can be generalized to index multiple texts. There are also generalizations for other combinatorial structures. The \emph{XBW transform} \cite{Ferragina2009b} is essentially an \FMindex{} for \emph{labeled trees}. The nodes of the tree are sorted by path labels from the node to the root of the tree. $\BWT$ stores the labels of the children of each node (leaf nodes require special treatment). If a node has $k$ children, we encode that as binary sequence $0^{k-1} 1$. We concatenate these sequences to form bitvector $B$, which is used for mapping lexicographic ranks of nodes to the corresponding BWT ranges. The labels of the children of node $i$ are found in $\BWT[B.\select(i, 1) + 1, B.\select(i + 1, 1)]$.

The \emph{generalized compressed suffix array} (GCSA) \cite{Siren2014} is a further generalization of the XBW transform for a class of graphs that includes \emph{directed acyclic graphs} and de Bruijn graphs. Before a graph can be indexed, we have to transform it into an equivalent graph, where the nodes can be unambiguously sorted by the labels of the right-maximal paths starting from them. In the worst case, the transformation increases the size of the graph exponentially. After sorting the nodes of the transformed graph in lexicographic order, we encode them using three sequences. $\BWT$ contains the labels of the predecessors, while bitvectors $\bvIN$ and $\bvOUT$ encode the indegrees and outdegrees of each node in the same way as bitvector $B$ of the XBW transform. \LFmapping{} uses $\select$ queries on bitvector $\bvIN$ to map nodes to BWT ranges, ordinary \LFmapping{} with $\BWT$ to map incoming edges to the corresponding outgoing edges, and $\rank$ queries on bitvector $\bvOUT$ to map the outgoing edges to the predecessor nodes.


\section{Path Indexes}\label{sect:path-indexes}

A \emph{path index} is a generalization of text indexes for \emph{labeled graphs}. Given a path index for \emph{input graph} $G = (V, E)$, we want to use the index to find the start nodes $v_{0} \in V$ of the paths $P = v_{0} \dotsm v_{\abs{X}-1}$ \emph{matching} the pattern $X$ (paths $P$ with $G.\glabel(P) = X$).

The design of a path index is a trade-off between the maximum supported query length and the size of the index. In the worst case, a graph may have up to $\sigma^{k}$ distinct labels for paths of length $k$ (ignoring the special treatment of characters $\#$ and $\$$), and the length of possible paths is unlimited in cyclic graphs. GCSA \cite{Siren2014} tried to avoid this by considering only a relatively simple class of graphs, using \emph{pruning heuristics} to simplify the graphs when necessary. The price of this was the possibility of \emph{false negatives}: path labels that exist in the graph but not in the index.

\subsection{Basic indexes}

The \emph{\kmer{k} index} is the simplest path index. In its most basic form, the \kmer{k} index consists of a parameter value $k$, a hash function $h$, and an array $A$ of \emph{key-value pairs} $(X, V_{X})$, where $X \in \Sigma^{k}$ and $V_{X} \subseteq V$. Given a \kmer{k} $X \in \Sigma^{k}$, we start looking for key $X$ from $A[h(X)]$, and list the set of start nodes $V_{X}$ as matches if we find it. Searching using a hash table is fast, but we can only search for patterns of length $k$, and the array requires a lot of space.

Another representation of the \kmer{k} index trades query performance for the ability to search for shorter patterns. Instead of using a hash table, we sort the key-value pairs by their keys, and store the pairs in array $A$ in sorted order. Given a pattern $X \in \Sigma^{\ast}$, $\abs{X} \le k$, we use binary search to find the range $A[sp, ep]$ of pairs $(X_{i}, V_{i})$, where pattern $X$ is a prefix of the key $X_{i}$. We then list the union $\bigcup_{i=sp}^{ep} V_{i}$ as the set of matches.

As de~Bruijn graphs and \kmer{k} indexes are both based on \kmer{k}s, we can use one to simulate the other. In order to define the de~Bruijn graph of a graph, we build a \kcollection{k} based on the collection $\mathcal{S}$ of the labels of the maximal paths in graph $G = (V, E)$. If sequence $S \in \mathcal{S}$ is the label of path $P = (v_{i})_{i \in Z}$ in the graph, we set $\mathcal{S}.\gnode(S, i) = v_{i}$ for all positions $i \in Z$. We then transform $\mathcal{S}$ into a \kcollection{k} by inserting the required the number of characters $\#$ to the beginning of each non-left-infinite sequence, and characters $\$$ to the end of each non-right-infinite sequence. If $S[i]$ is a $\#$ we inserted, we set $\mathcal{S}.\gnode(S, i) = s:j$, where $s$ is the start node of $G$ and $j$ is the distance to the nearest non-inserted $\#$ in $S$. Similarly, if $S[i]$ is an inserted $\$$, we set $\mathcal{S}.\gnode(S, i) = (t, j)$, where $t$ is the sink node and $j$ is the distance to the nearest non-inserted $\$$.

\begin{definition}[de~Bruijn graph of a graph]
Let $G$ be a labeled graph, and let $\mathcal{S}$ be the \kcollection{k} of maximal path labels in $G$. The \orderk{k} de~Bruijn graph of $\mathcal{S}$ is the \orderk{k} de~Bruijn graph of graph $G$.
\end{definition}

See Figure~\ref{figure:graph-dbg} for an example of a de~Bruijn graph of a graph. We can use a \kmer{k+1} index of graph $G = (V, E)$ to simulate the \orderk{k} de~Bruijn graph $G' = (V', E')$ of $G$. As the nodes of the de~Bruijn graph correspond to \kmer{k}s and the edges correspond to \kmer{k+1}s, we can represent the nodes by the adjacent edges. If we are interested in node $v \in V'$ with $G'.\gkey(v) = X$, we search for incoming edges $cX$ and outgoing edges $Xc$ for all $c \in \Sigma$. Determining the existence of a node requires $2 \sigma$ queries in the \kmer{k+1} index, and we learn the presence of adjacent nodes and edges in the process.

\begin{figure}[t!]
\includegraphics[width=396pt]{gcsa2_graph_dbg.pdf}
\caption{Left: Input graph $G = (V, E)$, with each node $v \in V$ labeled with $v:G.\glabel(v)$. Right: The \orderk{3} de~Bruijn graph $G' = (V', E')$ of graph $G$, with each node $v' \in V'$ labeled with $G'.\gkey(v')$ and $G'.\gvalue(v')$. Both: Edges $(t, s)$ are not shown. The highlighted path in the de~Bruijn graph is a false positive, as it consists of two disjoint paths in the input graph.}\label{figure:graph-dbg}
\end{figure}

On the other hand, we can use the \orderk{k} de~Bruijn graph $G' = (V', E')$ of graph $G = (V, E)$ as a \kmer{k} index of $G$ that supports queries of arbitrary length. Let $\mathcal{S}$ be the \kcollection{k} used for building the de~Bruijn graph. For each node $v \in V'$, we attach a set of nodes of graph $G$ as a \emph{value}: $G'.\gvalue(v) = \set{ \mathcal{S}.\gnode(S, i) \mid S \in \mathcal{S}, S[i, i+k-1] = G'.\gkey(v)}.$ Apart from some technicalities near the source/sink nodes, set $G'.\gvalue(v)$ is the set of start nodes of the paths $P$ in graph $G$ with $G.\glabel(P) = G'.\gkey(v)$. Due to the nature of de~Bruijn graphs, this index will not produce any false negatives. There may be \emph{false positives} (path labels that exist in the index but not in the input graph) with patterns longer than $k$, but we can avoid them by \emph{verifying} the results of such queries in the input graph.

\subsection{Path graphs}

De~Bruijn graphs are a special case of path graphs. They represent the paths of length $k$ in the \emph{input graph} as nodes and the pairs of paths overlapping on $k-1$ nodes of the input graph as edges. We can generalize the notion by allowing the nodes of the path graph to represent paths of different lengths.

\begin{definition}[Path graph]
Let $\mathcal{S}$ be a \kcollection{k} of the labels of maximal paths in graph $G = (V, E)$, and let $\mathcal{K}$ be a prefix-free set of strings of length at most $k$ containing $\#^{k}$ and $\$^{k}$. We assume that each right-maximal substring $S$ in $\mathcal{S}$ prefix-matches a string $K \in \mathcal{K}$, and that each string $K \in \mathcal{K}$ is a substring of $\mathcal{S}$. The \orderk{k} \emph{path graph} of graph $G$ with \emph{key set} $\mathcal{K}$ is a graph $G' = (V', E')$ such that
\begin{itemize}
\item each node $v_{K} \in V'$ represent a distinct key $K \in \mathcal{K}$, with $G'.\glabel(v_{K}) = K[0]$;
\item each node has a key $G'.\gkey(v_{K}) = K$ and a value $G'.\gvalue(v_{K}) = V_{K}$, where $V_{K}$ is the set of nodes $\mathcal{S}.\gnode(S, i) \in V$ for $S \in \mathcal{S}$ and positions $i$ such that $S[i, i+\abs{K}-1] = K$; and
\item each edge $(v_{K}, v_{K'}) \in E'$ represents the occurrence of substring $K[0] K'$ in $\mathcal{S}$ such that strings $K$ and $K[0] K'$ prefix-match.
\end{itemize}
We use the node corresponding to $\#^{k}$ as the source node $s$ and the node corresponding to $\$^{k}$ as the sink node $t$, adding the technical edge $(t, s)$ in the usual way.
\end{definition}

\begin{definition}[Path graph as an index]
Let $G = (V, E)$ be a graph, and let $G' = (V', E')$ be a path graph of $G$.
\begin{itemize}
\item Pattern $X \in \Sigma^{\ast}$ \emph{matches} node $v \in V'$, if there is a path $P$ in $G'$ with $G'.\glabel(P) = X$. We use $G'.\find(X)$ to denote the set of nodes $V'_{X} \subseteq V'$ matching the pattern.
\item If $V'_{X} \subseteq V'$ is the set of nodes matching pattern $X$, the set of \emph{occurrences} for the pattern is $G'.\locate(V'_{X}) = G'.\gvalue(V'_{X}) = \bigcup_{v \in V'_{X}} G'.\gvalue(v)$. We use $G'.\locate(X)$ as a shorthand for $G'.\locate(G'.\find(X))$.
\end{itemize}
\end{definition}

\begin{lemma}[No false negatives]\label{lemma:pg-fn}
Let $G' = (V', E')$ be a path graph of graph $G = (V, E)$, and let $X \in \patternset$ be a pattern string. Set $G'.\locate(X)$ contains the start nodes of all paths $P$ in graph $G$ with $G.\glabel(P) = X$.
\end{lemma}

\begin{lemma}[Context length]\label{lemma:pg-context}
Let $G' = (V', E')$ be a path graph, and let $X \in \patternset$ be a pattern. The set $G'.find(X)$ consists of all nodes $v' \in V'$ such that $X[0, m-1]$ is a prefix of $G'.\gkey(v')$, for a context length $m$, which depends on the graph and the pattern.
\end{lemma}

\begin{lemma}[Short keys]\label{lemma:pg-keys}
Let $G' = (V', E')$ be a path graph, where $\abs{G'.\gkey(u')} \le \abs{G'.\gkey(v')}$ for all edges $(u', v') \in E'$. Then
(a) $\abs{G'.\gpred(v', c)} \le 1$ for all nodes $v' \in V'$ and characters $c \in \Sigma$; and
(b) key $G'.\gkey(v')$ prefix-matches pattern $X \in \patternset$ for all nodes $v' \in G'.\find(X)$.
\end{lemma}

When used as an index, a path graph will not produce false negatives. On the other hand, we may encounter false positives already at path length $k'+1$, where $k'$ is the length of the shortest key in the key set. This is not very convenient for a path index. In the next section, we consider a class of path graphs that can be proven to be equivalent to de~Bruijn graphs.

\subsection{Pruned de Bruijn graphs}

De~Bruijn graphs often have nodes that are redundant when the graph is used as a path index. By carefully pruning the graphs, we get smaller graphs that are equivalent to \orderk{k} de~Bruijn graphs with patterns of length $k$ or less. These pruned de~Bruijn graphs naturally arise from GCSA construction. They are similar to manifold de Bruijn graphs \cite{Lin2014}.

\begin{definition}[Equivalent path graphs]
Let $G$ and $G'$ be two path graphs, and let $k > 0$ be a parameter value. We say that graphs $G$ and $G'$ are \emph{\kequivalent{k}}, if we have $G.\locate(X) = G'.\locate(X)$ for all patterns $X \in \patternset$ with $1 \le \abs{X} \le k$.
\end{definition}

\begin{definition}[Pruned de~Bruijn graph]
Let $G$ be a graph, and let $G'$ be an \orderk{k} path graph of $G$. Path graph $G'$ is an \orderk{k} \emph{pruned de~Bruijn graph}, if it is \kequivalent{k} to the \orderk{k} de~Bruijn graph of $G$.
\end{definition}

\begin{lemma}[No short false positives]\label{lemma:dbg-fp}
Let $G = (V, G)$ be a graph, let $G' = (V', E')$ be an \orderk{k} pruned de~Bruijn graph of $G$, and let $X \in \patternset$ be a pattern with $1 \le \abs{X} \le k$. Then $G'.\locate(X)$ is a set of start nodes $v\in V$ of paths $P$ matching the pattern in graph $G$.
\end{lemma}

\begin{lemma}[Pruning]\label{lemma:dbg-prune}
Let $G = (V, G)$ be a graph, let $G' = (V', E')$ be the \orderk{k} pruned de~Bruijn graph of $G$ with key set $\mathcal{K}$, let $K \in \Sigma^{\ast}$ be a string of length $\abs{K} > 0$, and let $V'_{K}$ be the set of nodes $v \in V'$ having string $K$ as a proper prefix of $G'.\gkey(v)$.
If $\abs{V'_{K}} > 0$ and $G'.\gvalue(u') = G'.\gvalue(v')$ for all $u, v \in V'_{K}$, the path graph with key set $(\mathcal{K} \setminus V'_{K}) \cup \set{K}$ is an \orderk{k} pruned de~Bruijn graph of $G$.
\end{lemma}

We can compress a de~Bruijn graph structurally by repeatedly merging sets of nodes sharing a common prefix of their keys, as long as the conditions of Lemma~\ref{lemma:dbg-prune} hold. Let $G' = (V', E')$ be an \orderk{k} pruned de~Bruijn graph, and let $G'' = (V'', E'')$ be the same graph after further pruning. Each node $v'' \in V''$ is an \emph{equivalence class} of nodes $V'(v'') \subseteq V'$ corresponding to a shared prefix $G''.\gkey(v'')$ of keys. For all $v' \in V'(v'')$, we have $G'.\gvalue(v') = G''.\gvalue(v'')$. See Figure~\ref{figure:pruned-index} for an example of a pruned de~Bruijn graph.

\begin{figure}[t!]
\includegraphics[width=396pt]{gcsa2_pruned_index.pdf}
\caption{Left: An \orderk{3} pruned de~Bruijn graph $G''$ \kequivalent{3} to the de~Bruijn graph in Figure~\ref{figure:graph-dbg}. Right: GCSA for graph $G''$. Leftward arrows show how backward searching proceeds, with the highlighted arrows demonstrating it from pattern $\dnaseq{T}$ to pattern $\dnaseq{AT}$. Rightward arrows tell where the samples for each node are located, with the highlighted ones showing them for the node with key $\dnaseq{CAT}$. The keys are not stored explicitly in the index.}\label{figure:pruned-index}
\end{figure}

\begin{definition}[Maximally pruned de~Bruijn graph]
Let $G'$ be a a pruned de~Bruijn graph of graph $G$ with key set $\mathcal{K}$. We say that $G'$ is \emph{maximally pruned}, if we cannot prune it using Lemma~\ref{lemma:dbg-prune} any further.
\end{definition}

\begin{lemma}[Maximal pruning]\label{lemma:dbg-maximal}
Let $G' = (V', E')$ be a maximally pruned de~Bruijn graph of graph $G = (V, E)$. Then $\abs{G'.\gkey(u')} \le \abs{G'.\gkey(v')}+1$ for all edges $(u', v') \in E'$.
\end{lemma}


\section{GCSA2}

Path graphs are essentially equivalent to the prefix-sorted automata used in the original paper on GCSA \cite{Siren2014}. As many of the technical details are different, we now take a look at how a GCSA of a path graph works. We also extend GCSA with techniques based on suffix trees.
See Figure~\ref{figure:pruned-index} for an example of a GCSA.
Appendix~\ref{appendix:construction} describes a construction algorithm that builds a GCSA for a maximally pruned \orderk{2k}, \orderk{4k}, or \orderk{8k} de~Bruijn graph from a set of paths of length $k$. While the algorithm is a similar prefix-doubling algorithm as in the original GCSA, it keeps the paths and graphs on disk to avoid excessive memory usage.

\subsection{GCSA for path graphs}

Let $G' = (V', E')$ be a path graph. We sort the nodes $V'$ by their keys in lexicographic order and then process the nodes in that order to generate the sequences $\BWT$, $\bvIN$, and $\bvOUT$. For each node $v' \in V'$, we append
\begin{itemize}
\item $\BWT$ with the predecessor labels $G.\glabel(u')$ for all edges $(u', v') \in E'$;
\item $\bvIN$ with the indegree $x = G.\gindegree(v')$ encoded as a binary sequence $0^{x-1} 1$; and
\item $\bvOUT$ with the outdegree $x = G.\goutdegree(v')$ encoded as a binary sequence $0^{x-1} 1$.
\end{itemize}
If node $v' \in V'$ has lexicographic rank $i$, the range of incoming edges $(u', v') \in E'$ to the node is $[sp_{in}, ep_{in}] = [\bvIN.\select(i, 1) + 1, \bvIN.\select(i+1, 1)]$. The labels of predecessor nodes $u'$ are encoded in $\BWT[sp_{in}, ep_{in}]$. Sorting the incoming edges by pairs $(\BWT[j], i)$, where $\BWT[j]$ corresponds to edge $(u', v')$, is equivalent to sorting them by strings $G'.\glabel(u') \cdot G'.\gkey(v')$. As multiple edges may have the same sort keys, our sorting algorithm must be stable. We get the desired sorting order by using \LFmapping: $j \mapsto \LF(j)$.

Consider now the outgoing edges. If the lexicographic rank of node $u' \in V'$ is $i'$, the range of outgoing edges $(u', v') \in E'$ is $[sp_{out}, ep_{out}] = [\bvOUT.\select(i', 1) + 1, \bvOUT.\select(i'+1, 1)]$. The edges are already sorted by keys $G'.\gkey(u')$. All outgoing edges from the same node have the same sort key, as there is nothing to distinguish them from one another. Because graph $G'$ is a path graph, we know that key $G'.\gkey(u')$ prefix-matches string $G'.\glabel(u') \cdot G'.\gkey(v')$. The sorting orders are therefore compatible. For every $j \in [sp_{in}, ep_{in}]$ for node $v' \in V'$, having $\LF(j) \in [sp_{out}, ep_{out}]$ for node $u' \in V'$ implies an edge $(u', v') \in E'$. If we sort the incoming edges $(u', v') \in E'$ stably by strings $G'.\glabel(u') \cdot G'.\gkey(v')$, we have $(u'_{1}, v'_{1}) < (u'_{2}, v'_{2})$ in that order, if $G'.\gkey(u'_{1}) < G'.\gkey(u'_{2})$.

We implement query $G'.\find(X)$ with \emph{backward searching}. Let $X \in \patternset$ be a pattern. If $\abs{X} = 0$, query $G'.\find(X)$ returns the lexicographic range $[0, \abs{V'}-1]$ containing all nodes of the path graph. Now assume that $\abs{X} \ge 1$ and that query $G'.\find(X[i+1, \abs{X}-1])$ has returned range $[sp_{i+1}, ep_{i+1}]$. We want to find the lexicographic range corresponding to the union of sets $G'.\gpred(v', X[i])$ over nodes $v' \in G'.\find(X[i+1, \abs{X}-1])$. We map the node range $[sp_{i+1}, ep_{i+1}]$ to range $[sp_{in}, ep_{in}]$ of incoming edges (with $sp_{in} = 0$ if $sp_{i+1} = 0$); the incoming edges to the corresponding range of outgoing edges $[sp_{out}, ep_{out}]$; and the outgoing edges to the range $[sp_{i}, ep_{i}]$ of nodes $G'.\find(X[i, \abs{X}-1])$:
\begin{align*}
[sp_{in}, ep_{in}] & = [\bvIN.\select(sp_{i+1}, 1) + 1, \bvIN.\select(ep_{i+1}+1, 1)]; \\
[sp_{out}, ep_{out}] & = [\LF(sp_{in}, X[i]), \LF(ep_{in}+1, X[i]) - 1];\ \textrm{and} \\
[sp_{i}, ep_{i}] & = [\bvOUT.\rank(sp_{out}, 1), \bvOUT.\rank(ep_{out}, 1)].
\end{align*}
We can think this as a generalization of \LFmapping: $[sp_{i}, ep_{i}] = G'.\LF([sp_{i+1}, ep_{i}], X[i])$.

Query $G'.\locate(X)$ requires retrieving the values $G'.\gvalue(v')$ for nodes $v' \in V'$ in the lexicographic range returned by query $G'.\find(X)$ and removing duplicates. Storing the values explicitly for all nodes would make the path index several times larger than the graph structure described above. To avoid that, GCSA uses a similar \emph{sampling} scheme to the one used in FM\nobreakdash-indexes. We assume that the nodes $v \in V$ of the input graph $G = (V, E)$ are integers, and that the node numbering has been chosen with our sampling scheme in mind. If $(u, v) \in E$ is the only outgoing edge from node $u$ and the only incoming edge to node $v$, it should be that $v = u+1$.

Let $v' \in V'$ be a node of the path graph. We sample the values $G'.\gvalue(v')$, (a) if there are multiple incoming edges to node $v'$; (b) if $v'$ is the source node $s$; or (c) if $(u', v') \in E'$ is the only incoming edge to node $v'$, and $G'.\gvalue(v') \ne \set{u+1 \mid u \in G'.\gvalue(u')}$. We may also sample the values for some nodes on long unary paths for performance reasons. If the values $G'.\gvalue(v')$ has not been sampled, we can derive them from sampled values by following the incoming edges backwards.

Following edges backwards is based on a similar generalization of \LFmapping{} as backward searching. If node $v' \in V'$ has lexicographic rank $i$, the lexicographic rank of its only predecessor is
$G'.\LF(i) = \bvOUT.\rank(\LF(\bvIN.\select(i, 1) + 1), 1)$. If lexicographic rank $G'.\LF^{k}(i)$ corresponding to node $w' \in V'$ is the first sampled node we encounter, we know that $G'.\gvalue(v') = \set{w+k \mid w \in G'.\gvalue(w')}$.

Let $B_{S}[0, \abs{V'}-1]$ be a bitvector marking the sampled nodes. If we have sampled the values for the node $v' \in V'$ with lexicographic rank $i$, we mark that as $B_{S} = 1$. We can then determine the rank of node $v'$ among the sampled nodes as $j = B_{S}.\rank(i, 1)$. For each sampled node $v' \in V$, we store the size of the value set $\abs{G'.\gvalue(v')}$ in another bitvector $B_{V}$, using the same encoding as in bitvectors $\bvIN$ and $\bvOUT$. We then store the samples in array $V_{S}$ in the same order, using $\log \abs{V}$ bits each. The sampled values for node $v'$ with rank $j$ among the sampled nodes can be found at $V_{S}[B_{V}.\select(j, 1) + 1, B_{V}.\select(j+1, 1)]$.

If $G'.\gpred(v', c) \le 1$ for all nodes $v' \in V'$ and characters $c \in \Sigma$, such as in de~Bruijn graphs and maximally pruned de~Bruijn graphs, we can use a simplified encoding for the graph. We replace sequences $\BWT$ and $\bvIN$ with \emph{indicator bitvectors} $B_{c}[0, \abs{V'}-1]$ for all $c \in \Sigma$. If node $v' \in V$ has a predecessor with label $c \in \Sigma$, we set$B_{c}[i] = 1$. Backward searching is now simpler: $[sp_{i}, ep_{i}] = [G'.\LF(sp_{i+1}, c), G'.\LF(ep_{i+1}+1, c) - 1]$, where
$$
G'.\LF(i, c) = \bvOUT.\rank(C[c] + B_{c}.\rank(i, 1), 1).
$$
We replace two expensive queries ($\bvIN.\select()$ and $\BWT.\rank()$) with a single $\rank$ query on a bitvector. On the other hand, computing $G'.\LF(i)$ is now more expensive, as we have to look at $B_{c}[i]$ for all $c \in \Sigma$ to determine $\BWT[i]$. The alternative is to follow outgoing edges when searching for samples; this requires two $\select$ queries per edge.

\subsection{Extensions}

GCSA is a generalization of FM\nobreakdash-indexes for path graphs. Because path graphs are quite similar to strings, at least when compared with other labeled graphs, we can often generalize algorithms using FM\nobreakdash-indexes and data structures extending them to work with path graphs.

Let $G' = (V', E')$ be an \orderk{k} (pruned) de~Bruijn graph, and let $v'_{0}, \dotsc, v'_{\abs{V'}-1}$ be its nodes in lexicographic order by their keys. We define the \emph{LCP array} of graph $G'$ in the same way as in GCSA construction: $\LCP[i]$ is the length of the longest common prefix of keys $G'.\gkey(v'_{i-1})$ and $G'.\gkey(v'_{i})$, with $\LCP[0] = 0$. The following extensions are based on the trie of keys $G'.\gkey(v')$ for all nodes $v' \in V'$, with unary paths compacted in the same way as in the suffix tree. The compacted trie can be considered the \emph{suffix tree of the path graph}.

The \emph{LCP interval tree} \cite{Abouelhoda2004} is an alternate representation of the suffix tree. Each node $v$ of the suffix tree is represented by the lexicographic range $[sp, ep]$ matching the label $\ell(v)$. These ranges can be determined from the LCP array. If we augment the FM\nobreakdash-index with an LCP array supporting \emph{next/previous smaller value} queries and \emph{range minimum queries}, we get a space-efficient data structure providing the full functionality of the suffix tree \cite{Fischer2009a}.

If we build an $x$\nobreakdash-ary tree over the LCP array of graph $G'$, with each internal node storing the minimum LCP value in the corresponding range of the LCP array, we can support the required queries in $\Oh{x + \log_{x} \abs{V'}}$ time using $\frac{x}{x-1} \abs{V'} \log k$ bits of space. Because nodes of a path graph may match patterns that do not prefix-match their keys, we have to be careful with the suffix tree operations we use. By Lemma~\ref{lemma:pg-context}, the ranges returned by $\find$ queries always correspond to prefixes of the pattern. Hence we can safely use $\parent$ queries with such ranges.

BWA-MEM \cite{Li2013} aligns reads to reference genomes by finding \emph{maximal exact matches} between the read and the reference. It stores both the reference and its reverse complement are stored in the same index, which allows it to extend the pattern in both directions. GCSA cannot use similar techniques, as we cannot guarantee that the length of the lexicographic range matching pattern $X$ is the same as the length of the range matching its reverse complement $\revcomp{X}$ (that the key set contains key $K$ if and only if it contains the reverse complement $\revcomp{K}$). Instead of using bidirectional BWT, we search for maximal exact matches using \LFmapping{} and the $\parent$ operation \cite{Ohlebusch2010a}. We have implemented a GCSA-based read aligner using that algorithm in vg \cite{Garrison2014-2016}.

In an ordinary FM\nobreakdash-index, the length of a lexicographic range tells the number of distinct pointers in the range. In GCSA, each node $v' \in V'$ may have multiple values (pointers), and each value may occur in multiple nodes. Determining the  number of distinct start nodes with a $\locate$ query can be slow. Hence we need additional structures to support efficient \emph{counting queries}. The problem is similar to determining the \emph{document frequency} of a pattern. Given a collection of documents, the document frequency of pattern $X$ is the number of distinct documents that contain occurrences of the pattern. We can augment an FM\nobreakdash-index with a bitvector of length $2n-d$, where $n$ is the total size of the document collection and $d$ is the number of documents, to compute document frequencies efficiently \cite{Sadakane2007a}.

Let $v$ be a suffix tree node corresponding to lexicographic range $[sp, ep]$ in the collection, and let $\countq(v)$ be the document frequency of the label $\ell(v)$. If nodes $v_{0}, \dotsc, v_{m-1}$ are the children of node $v$, we determine the number of \emph{redundant} documents in node $v$ as $R(v) = \sum_{i=0}^{m-1} \countq(v_{i}) - \countq(v)$. Consider now the \emph{inorder traversal} of the suffix tree, where we may encounter the same nodes multiple times. We create an array $R[0, n-2]$ of the values $R(v)$ over all internal nodes $v$. If the $i$th internal node we encounter is our first visit to node $v$, we set $R[i] = R(v)$. For subsequent visits to the same node, we set $R[j] = 0$. Range $R[sp, ep-1]$ now covers the internal nodes in the subtree rooted at node $v$. We can now determine document frequencies as $\countq(v) = (ep+1-sp) - \sum_{i=sp}^{ep-1} R[i]$. If we encode array $R$ in unary, with value $x$ becoming $0^{x} 1$, we get a bitvector $B_{R}[0, n-d-1]$, where we can compute the sums with $\select$ queries:
$$
\sum_{i=a}^{b} R[i] = (B_{R}.\select(b+1, 1) - b) - (B_{R}.\select(a, 1) + 1 - a).
$$

For value counting, we use array $R$ to store the number of redundant values in each suffix tree node. We also use another array $A[0, \abs{V'}-1]$, which tells the number of additional values in each node $v'_{i} \in V'$ as $A[i] = \abs{G'.\gvalue(v'_{i})}-1$. We then encode array $A$ as a bitvector $B_{A}$ in the same way as bitvector $B_{R}$ above. The number of distinct start nodes for paths matching pattern $X$ (with $\abs{X} \le k$) is then
$$
G'.\countq(X) = G'.\countq(G'.\find(X)) = (ep+1-sp) + \sum_{i=sp}^{ep} A[i] - \sum_{i=sp}^{ep-1} R[i],
$$
where $[sp, ep]$ is the lexicographic range returned by the $\find$ query. The bitvectors are often highly compressible \cite{Gagie2015}, but GCSA already uses one of the compression schemes implicitly when it prunes the de~Bruijn graph.


\section{Implementation and Experiments}

GCSA2 has been implemented as the path index library of vg \cite{Garrison2014-2016}. The implementation is in C++ and the source code is available on GitHub (\url{https://github.com/jltsiren/gcsa2}). As the implementation uses the \emph{Succinct Data Structures Library 2.0} (SDSL) \cite{Gog2014b} and \emph{libstdc++ parallel mode}, it requires g++ version~4.9 or later to compile. As a general design principle, fast succinct data structures have been chosen over the smaller but slower compressed data structures.

The \emph{variation graphs} used in vg have strings as node labels. The average length of a node label is typically around 10~bases. Each node can be traversed both in forward orientation and in reverse complement orientation, and edges may cross from the forward strand of one node to the reverse complement strand of another node, or the other way around. When extracting paths from a variation graph, the graph is implicitly converted into an input graph with single-character labels. Input graph nodes corresponding to the initial offsets of variation graph node labels are always selected as samples for performance reasons.

The following experiments were done on a system with two 16\nobreakdash-core AMD Opteron 6378 processors and 256~gigabytes of memory running Ubuntu~12.04 on Linux kernel~3.2.0. Input files, final indexes, and temporary files were all stored on a distributed Lustre file system. We used vg version~1.3.0 for processing the graphs, GCSA2 version~0.6 for building the indexes, and GCSA2 version~0.6.1 for the query benchmarks.

We built vg graphs based from the human reference genome (GRCh37) and the 1000~Genomes Project phase~3 variation \cite{1000GP2015}. To avoid excessive growth, we pruned complex regions of the graphs using \texttt{vg mod -p -l 16 -e 4 | vg mod -S -l 100}, removing paths where \kmer{16}s cross more than $4$ nontrivial edges and subgraphs shorter than $100$ bases. We then extracted paths of length $16$ from the forward strands of all chromosomes. There were a total of 4.80~billion paths with 1.53~billion distinct labels. We then built GCSA2 using $1$, $2$, and $3$ doubling steps, producing \orderk{32}, \orderk{64}, and \orderk{128} indexes, respectively. The results are summarized in Table~\ref{table:construction}.

\begin{table}[t!]
\begin{center}
\caption{GCSA2 construction with different orders of the path graph. Billions of nodes in the de~Bruijn graph and the pruned de~Bruijn graph; index size in gigabytes; construction time in hours; peak memory and disk usage in gigabytes; and disk I/O volume for reading and writing in terabytes.}\label{table:construction}
\begin{tabular}{c|ccc|ccc|cc}
\hline
\textbf{Order} & \textbf{Nodes} & \textbf{Pruned} & \textbf{Index} & \textbf{Time} & \textbf{Memory} & \textbf{Disk} & \textbf{Read} & \textbf{Write} \\
\hline
 32 & 6.23G & 4.39G & 13.7 GB & 9.85 h & 63.2 GB & 401 GB & 1.55 TB & 1.05 TB \\
 64 & 16.9G & 5.27G & 14.2 GB & 13.6 h & 56.1 GB & 424 GB & 2.23 TB & 1.71 TB \\
128 &  118G & 5.76G & 15.3 GB & 18.0 h & 56.9 GB & 489 GB & 3.00 TB & 2.47 TB \\
\hline
\end{tabular}
\end{center}
\end{table}

A single-strand whole-genome index can be built overnight with 96~gigabytes of memory. Even 64~gigabytes is enough, but the lack of sufficient disk cache may make the construction slower. The size of the de~Bruijn graph grows exponentially at roughly $1.031^{k} \cdot 2.38$~billion nodes, while the growth rate of the pruned de~Bruijn graph is much slower.\footnote{The merging step, as currently implemented, does not produce a maximally pruned graph. It consists of a pruning step, followed by merging the paths with identical labels.} The index itself grows even more slowly with $k$, as we sample the values more often in lower order graphs.

We extracted \kmer{16}s, \kmer{32}s, and \kmer{64}s from the vg graphs using \texttt{vg sim}, and queried for them in the \orderk{64} index using a single thread. The results can be seen in Table~\ref{table:benchmark}. Not all patterns could be matched to the graphs they were extracted from, as some paths were pruned before index construction. The $\find$ and $\locate$ queries are 5\nobreakdash--10 times slower than in a fast whole-genome FM\nobreakdash-index. There are two main reasons: (1) we use $\select$ queries, which are slower than $\rank$ queries on plain bitvectors \cite{Gog2014}; and (2) $\locate$ queries generate duplicates, which must be filtered out. Switching to the simplified encoding for maximally pruned graphs would make $\find$ queries faster and $\locate$ queries slower.

\begin{table}[t!]
\begin{center}
\caption{Performance benchmarks using an \orderk{64} GCSA2. Pattern length; number of patterns; number of matching patterns; number of matching nodes; number of distinct occurrences; average time for $[sp, ep] = \find(X)$, $\parent(sp, ep)$, and $\countq(sp, ep)$ queries in microseconds; and average time for $\locate(sp, ep)$ queries in microseconds or milliseconds.}\label{table:benchmark}
\begin{tabular}{c|cc|cc|cccc}
\hline
\textbf{Length} & \textbf{Patterns} & \textbf{Occs} & \textbf{Nodes} & \textbf{Values} & $\find()$ & $\parent()$ & $\countq()$ & $\locate()$ \\
\hline
16 & 351584 & 347453 & 1829M &  872M & 18.1 \textmu{}s & 0.40 \textmu{}s & 0.94 \textmu{}s & 26.2 ms \\
32 & 351555 & 333258 & 52.6M & 34.3M & 37.9 \textmu{}s & 0.28 \textmu{}s & 0.43 \textmu{}s & 468 \textmu{}s \\
64 & 351567 & 326101 & 0.33M & 1.35M & 88.9 \textmu{}s & 0.36 \textmu{}s & 0.42 \textmu{}s & 10.3 \textmu{}s \\
\hline
\end{tabular}
\end{center}
\end{table}


\section{Conclusions}

GCSA2 is a path index for variation graphs. It uses a structurally compressed de~Bruijn graph of the paths in the input graph as an index, and encodes that with a generalization of the FM\nobreakdash-index. The index also incorporates extensions based on a generalization of suffix trees. GCSA2 has been integrated in the variation graph toolkit vg, where it is used e.g.~for read alignment based on maximal exact matches.

We can build a forward strand whole-genome index overnight on a system with 96~gigabytes of memory and a few hundred gigabytes of fast disk space. The index itself requires less than 16~gigabytes of memory. Query performance is roughly 5\nobreakdash--10 times slower than for a fast FM\nobreakdash-index for sequences. GCSA2 can search for patterns at roughly 0.8\nobreakdash--1.0~MB/s and locate 100,000\nobreakdash--300,000 occurrences per second using a single CPU core. As with other FM\nobreakdash-indexes, the speedup from distributing the queries on multiple cores is quite high.

The compressed suffix tree used in GCSA2 may also be useful as a text index, as it is both easy to implement and fast in practice. As long as the average LCP value is low, we can generalize the byte array encoding of the LCP array \cite{Abouelhoda2004} to implement it space-efficiently. We use an array of $m$\nobreakdash-bit integers for the LCP array and the $x$\nobreakdash-ary tree, mark the values that are too large for $m$~bits with the largest possible value, and store them separately.

We often have to prune complex regions of the input graph before indexing it. This causes false negatives: paths that exist in the input graph but not in the index. We could adapt techniques from the hypertext index \cite{Thachuk2013} to avoid the false negatives. We create a primary graph based on known \emph{haplotypes} and build a GCSA index for both strands of the graph. Then we create a matrix of additional edges corresponding to potential \emph{recombinations} in the path graph. We then search for pattern $X$ and its reverse complement $\revcomp{X}$ in the index. For all $0 < i < \abs{X}$, we can combine the partial matches $\find(X[i, \abs{X}-1])$ and $\find(\revcomp{X}[\abs{X}-i, \abs{X}-1])$ into complete matches crossing one recombination edge with a range query in the edge matrix.

While graphs are a natural formalism for representing genetic variation, they cannot represent certain types of \emph{rearrangements} adequately. For example, if sequence $S$ can occur in different positions of the genome (e.g.~$ASBC$ and $ABSC$), we can have a single copy or multiple copies of $S$ in the graph. Neither of the options is good for a reference genome. With a single copy, we create paths in the reference that do not correspond to any valid genome. With the second option, we duplicate sequences that are not only identical but also functionally the same. One solution is to switch from graphs to \emph{context-free grammars}. As long as the grammar is non-nested, we can handle it with the hypertext index. We build a hypertext index for the high level graph, where each node is labeled with a nonterminal symbol, while each nonterminal expands into a subgraph indexed in GCSA.


\subparagraph*{Acknowledgements.}

I thank Erik Garrison, Richard Durbin, and Adam Novak for the fruitful discussions we had while I developed the GCSA2 index. Many extensions over the original GCSA and clarifications of the assumptions I made are a direct result of those discussions.


\bibliography{paper}


\clearpage
\appendix
\section{Proofs of Lemmas}\label{appendix:proofs}

\begin{proof}[Proof of Lemma~\ref{lemma:pg-fn} (No false negatives)]
Let $\mathcal{S}$ be the \kcollection{k} used for building the path graph, and let $P$ be a path starting from node $v_{0} \in V$ with $G.\glabel(P) = X$. The collection contains a sequence $S \in \mathcal{S}$ such that $S[i, i+\abs{X}-1] = X$ and $\mathcal{S}.\gnode(S, i) = v_{0}$.

For all positions $j$ with $i \le j < i+\abs{X}$, there is a node $v'_{j} \in V'$ with $G'.\glabel(v'_{j}) = S[j]$ and $G'.\gkey(v'_{j}) = S[j, j+\abs{G'.\gkey(v'_{j})}-1]$.
By definition, the path graph has an edge $(v'_{j}, v'_{j+1}) \in E'$ for $i \le j < i+\abs{X}-1$.
Hence $P' = v'_{i} \dotsm v'_{i+\abs{X}-1}$ is a path in $G'$ with $G'.\glabel(P') = X$.
As path $P'$ starts from node $v'_{i} \in V'$, node $v'_{i}$ is included in the set $G'.\find(X)$.
Furthermore, $v_{0} = \mathcal{S}.\gnode(S, i) \in G'.\gvalue(v'_{i}) \subseteq G'.\locate(X)$.
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lemma:pg-context} (Context length)]
If $\abs{X} \le 1$, the statement is true by definition for $m = \abs{X}$. Now assume that $M_{i+1} = G'.\find(X[i+1, \abs{X}-1])$ is the set of all nodes $v' \in V'$ such that substring $X[i+1, i+m]$ is a prefix of $G'.\gkey(v')$.

Consider the set $M_{i} = \bigcup_{v' \in M_{i+1}} G'.\gpred(v', X[i])$, and assume that it is nonempty. Edge $(u', v') \in E'$ exists if and only if key $G'.\gkey(u')$ prefix-matches string $G'.\glabel(u') \cdot G'.\gkey(v')$. Hence $u' \in M_{i}$ if and only if key $G'.\gkey(u')$ prefix-matches string $X[i, i+m]$. If $\abs{M_{i}} > 1$, string $X[i, i+m]$ is a proper prefix of key $G'.\gkey(u')$ for all nodes $u' \in M_{i}$ due to the prefix-free property, and we can continue with context length $m+1$. Otherwise the context length becomes $\min(m+1, \abs{G'.\gkey(u')})$ for the only node $u' \in M_{i}$.
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lemma:pg-keys} (Short keys)]
(a) If node $v'$ has multiple predecessors with label $c$, the keys of the predecessors must be longer than string $c \cdot G'.\gkey(v')$, as the key set is prefix-free.

(b) By the construction in the proof of Lemma~\ref{lemma:pg-context}, the context length for pattern $X$ in graph $G'$ is $\min(\abs{X}, \abs{G'.\gkey(v')})$.
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lemma:dbg-fp} (No short false positives)]
We may assume without loss of generality that graph $G'$ is a de~Bruijn graph.

Let $v' \in G'.\find(X)$ be a node. By Lemma~\ref{lemma:pg-keys}, pattern $X$ prefix-matches key $G'.\gkey(v')$. For every node $v \in G'.\gvalue(v')$, there is a substring $S[i, i+k-1] = G'.\gkey(v'_{0})$ in the \kcollection{k} $\mathcal{S}$ used for building graph $G'$, with $\mathcal{S}.\gnode(S, i) = v$. Prefix $S[i, i+\abs{X}-1] = X$ of the substring corresponds to a path with label $X$ starting from node $v$ in graph $G$.
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lemma:dbg-prune} (Pruning)]
Let $G_{d} = (V_{d}, E_{d})$ be the \orderk{k} de~Bruijn graph of $G$, let $G'' = (V'', E'')$ be the path graph corresponding to the new key set, and let $\mathcal{S}$ be the \kcollection{k} used for building the path graphs.

Let $X \in \patternset$ be a pattern with $1 \le \abs{X} \le k$, and let $S[i, i+k-1] = G_{d}.\gkey(v_{0})$ be a substring of $\mathcal{S}$, where $v_{0} \in G_{d}.\find(X)$. By Lemma~\ref{lemma:dbg-fp}, $X$ is a prefix of the substring. We extend the substring to length $\abs{X}+k-1$ without changing its starting position. The extended substring $S[i, i+\abs{X}+k-2]$ corresponds to a path $P = v_{0} \dotsm v_{\abs{X}}$ with label $X$ in the de~Bruijn graph, with $G_{d}.\gkey(v_{j}) = S[i+j, i+j+k-1]$. If we change each node $v_{j}$ to the corresponding equivalence class $v''_{j} \in V''$, we get a path with label $X$ in graph $G''$.

Now let $P'' = v''_{0} \dotsm v''_{\abs{X}-1}$ be a path matching pattern $X$ in graph $G''$. If $\abs{X} = 1$, we can choose any $v_{0} \in V_{d}(v''_{0})$. Now assume that we have chosen node $v_{j+1}$ from the equivalence class $V_{d}(v''_{j+1})$ and that $X[j+1, \abs{X}-1]$ is a prefix of $G_{d}.\gkey(v_{j+1})$. As edge $(v''_{j}, v''_{j+1}) \in E''$ exists, it must be that $\abs{G.\gpred(v, X[j])} > 0$ for a node $v \in G''.\gvalue(v''_{j+1}) = G_{d}.\gvalue(v_{j+1})$. Therefore substring $X[j] \cdot G_{d}.\gkey(v_{j+1})$ exists in $\mathcal{S}$, and the node $v_{j} \in V_{d}$ with $G_{d}.\gkey(v_{j}) = (X[j] \cdot G_{d}.\gkey(v_{j+1}))[0, k-1]$ has $X[j, \abs{X}-1]$ as a prefix of its key. As $G''.\gkey(v''_{j})$ is a prefix of $X[j] \cdot G''.\gkey(v''_{j+1})$, which is a prefix of $X[j] \cdot G_{d}.\gkey(v_{j+1})$, key $G''.\gkey(v''_{j})$ is also a prefix of $G_{d}.\gkey(v_{j})$, and hence $v_{j} \in V_{d}(v''_{j})$. When $j = 0$, we can extend the substring as above to get a path matching the pattern in $G_{d}$, with $v_{0}$ as the start node.

Given $v_{0} \in G_{d}.\find(X)$, we can build a path $P'' = v''_{0} \dotsm v''_{\abs{X}-1}$ matching the pattern in graph $G''$, with $v_{0} \in V_{d}(v''_{0})$. We can also start from path $P''$ and determine the node $v_{0}$. As $G_{d}.\gvalue(v_{0}) = G''.\gvalue(v''_{0})$, we have $G_{d}.\locate(X) = G''.\locate(X)$.
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lemma:dbg-maximal} (Maximal pruning)]
Let $G_{d} = (V_{d}, E_{d})$ the de~Bruijn graph of graph $G$ with the same order $k$ as graph $G'$, and let $\mathcal{S}$ be the \kcollection{k} used for building the path graphs. If $v' \in V'$ is a node, then $G_{d}.\gvalue(v) = G'.\gvalue(v')$ for all nodes $v \in V_{d}(v')$.

Assume that $\abs{G'.\gkey(u')} > \abs{G'.\gkey(v')}+1$ for an edge $(u', v') \in E'$. Then string $G'.\glabel(u') \cdot G'.\gkey(v')$ must then be a prefix of key $G'.\gkey(u')$. There cannot be edges $(u', w')$ to other nodes $w' \ne v'$, as keys $G'.\gkey(v')$ and $G'.\gkey(w')$ would prefix-match.

Let $S[i, i+\abs{G'.\gkey(u')}-1] = G'.\gkey(u')$ be a substring in the \kcollection{k}. Because graph $G'$ is a pruned de~Bruijn graph, the set of nodes $\mathcal{S}.\gnode(S, i+1)$ over all occurrences of substring $G'.\gkey(u')$ in the \kcollection{k} is $G'.\gvalue(v')$. As node $u'$ has no other successors, set $G'.\gvalue(u')$ is the union of sets $G.\gpred(v, G'.\glabel(u'))$ for all nodes $v \in G'.\gvalue(v')$.

The above is true for all nodes $x' \in G'.\gpred(v', G'.\glabel(u'))$. Hence we can prune graph $G'$ further using string $G'.\glabel(u') \cdot G'.\gkey(v')$ as the new key in Lemma~\ref{lemma:dbg-prune}.
\end{proof}


\section{Index Construction}\label{appendix:construction}

GCSA construction \cite{Siren2014} is based on the original \emph{prefix-doubling} algorithm for suffix array construction \cite{Manber1993}. The original GCSA started from paths of length $1$ in the input graph, and then repeatedly \emph{joined} paths of length $k$ into paths of length $2k$, until each path had a distinct label. The resulting path graph was essentially an unlimited-order pruned de~Bruijn graph and supported queries of arbitrary length.

We use a variant of that algorithm with GCSA2. Let $G = (V, E)$ be the input graph. We extract all paths of length $k$ (typically for $k = 16$) from graph $G$. For each path $P = v_{0} \dotsm v_{\abs{P}-1}$, we store several fields. \emph{Key} $P.\gkey$ encodes $G.\glabel(P)$ as a sequence of lexicographic ranks of \kmer{k}s. If $\abs{P}$ is not an integer multiple of $k$, the key consists of the \kmer{k} ranks for the lexicographically smallest \kmer{(\lceil \abs{P}/k \rceil \cdot k)} having $G.\glabel(P)$ as a prefix, followed by the rank of the last \kmer{k} in the largest such \kmer{(\lceil \abs{P}/k \rceil \cdot k)}. \emph{Value} $P.\gvalue$ is the start node $v_{0}$ of the path. We store the set of \emph{predecessor labels} $\set{c \in \Sigma \mid \abs{G.\gpred(v_{0}, c)} > 0}$ as $P.\gpred$. For each possible \emph{extension node} $v \in \set{v \in V \mid (v_{\abs{P}-1}, v) \in E}$, we create a new copy of the path and store the node as $P.\gext = v$.

The construction uses several supporting structures. We build an \orderk{k} \emph{de~Bruijn graph} $G_{d} = (V_{d}, E_{d})$ of the path labels and encode it as a GCSA, using the predecessor labels $P.\gpred$ for determining the edges. Let $v_{0}, \dotsc, v_{\abs{V_{d}}-1}$ be the nodes of the de~Bruijn graph in lexicographic order by the keys. We use two additional arrays: \emph{the LCP array} $\LCP[0, \abs{V_{d}}-1]$, where $\LCP[i]$ is the length of the longest common prefix of keys $G_{d}.\gkey(v_{i-1})$ and $G_{d}.\gkey(v_{i})$ (with $\LCP[0] = 0$), and the \emph{last character array} $L[0, \abs{V_{d}}-1]$, where $L[i] = G_{d}.\gkey(v_{i})[k-1]$. The LCP array is stored in a wavelet tree for fast \emph{range minimum queries} \cite{Gagie2012a}.

Because we have to store path labels explicitly in the keys, we only do a limited number of \emph{doubling steps}, typically $2$ or $3$. After $d$ doubling steps, the length of the paths is $2^{d} k$, and we can use them to build a maximally pruned \orderk{(2^{d} k)} de~Bruijn graph. Each doubling step consists of a \emph{pruning} step, followed by an \emph{extension} step. The pruning step uses a limited form of Lemma~\ref{lemma:dbg-prune} and applies it to all possible ranges of paths. Given two paths $P$ and $P'$, we can determine the longest common prefix of the path labels by using the keys $P.\gkey$ and $P'.\gkey$ and the LCP array. If all paths with a certain prefix of their labels start from the same node, we merge them into a single path $Q$ with $Q.\gkey$ based on the shared prefix and $Q.\gext = -1$.

The extension step transforms the current set of paths of length (up to) $k'$ and transforms it into a set of paths of length (up to) $2k'$. If $P$ is a path with $P.\gext = -1$, we use it as such. If $P.\gext = P'.\gvalue$ for paths $P$ and $P'$, we create a new path $PP'$. We set $(PP').\gkey$ according to the concatenation of the path labels, take $\gvalue$ and $\gpred$ from path $P$, and take $\gext$ from path $P'$. If we have another path $Q$ with $Q.\gkey = P.\gkey$ such that $QP'$ is a path, and if $P'.\gext = -1$, all possible \kmer{2k'} extensions of label $G.\glabel(PP')$ are also labels of paths starting from node $Q.\gvalue$, and the other way around. Hence paths $PP'$ and $QP'$ can be represented by a single node in a pruned de~Bruijn graph.

The doubling steps are followed by the \emph{merging steps}, which transforms the paths of length (up to) $k'$ into the nodes of a maximally pruned de~Bruijn graph $G'' = (V'', E'')$. First we merge the paths with identical keys into the nodes of a pruned de~Bruijn graph $G' = (V', E')$. If paths $P_{0}, \dotsm, P_{m-1}$ all have the same key, we create a node $v' \in V'$ with the shared key as $G'.\gkey(v')$ and with $G'.\gvalue(v') = \bigcup_{i=0}^{m-1} P_{i}.\gvalue$. We also store the union of predecessor labels as $G'.\gpred(v') = \bigcup_{i=0}^{m-1} P_{i}.\gpred$. Then we apply Lemma~\ref{lemma:dbg-prune} maximally, transforming graph $G'$ into graph $G''$.

Storing the paths and graphs may require hundreds of gigabytes of memory when indexing whole-genome variation graphs. To avoid that, we store them on \emph{disk} when possible. Each chromosome forms a subgraph that is disjoint from the other chromosomes, except near the source node and the sink node. Hence we can store the paths corresponding to each chromosome in a separate file, sorted by their labels in lexicographic order. A doubling step can be done separately for each of the chromosomes. A pruning step takes a set of sorted lists paths and merges the lists. It keeps reading paths into a buffer, until it has found a maximal range of paths that can be merged. The merged path is written into the new file for that chromosome, and the original range of paths is removed from the buffer. The merging step is mostly the same as a pruning step, but the output format is different.

After storing the nodes $V''$ of the maximally pruned \orderk{k'} de~Bruijn graph $G'' = (V'', E'')$ on disk, we proceed to \emph{building the index}. Sequences $\BWT$ and $\bvIN$ can be generated from the predecessor sets $G''.\gpred(v'')$ we have stored, but the outdegree sequence $\bvOUT$ requires further processing. Because graph $G''$ is a path graph, there is an edge $(u'', v'') \in E''$ if and only if string $c \cdot G''.\gkey(v'')$ prefix-matches key $G''.\gkey(u'')$ and $c \in G''.\gpred(v')$. We determine the edges and produce the outdegree sequence by scanning the node file sequentially with $\sigma+1$ pointers. The pointer corresponding to node $v''$ scans the entire file, while each of the remaining $\sigma$ pointers scans only the range of nodes $u''$ with $G''.\glabel(u'') = c$ for a $c \in \Sigma$. We can also sample the nodes for $\locate$ queries during the same scans.

Checking whether key $G''.\gkey(u'')$ prefix-matches string $c \cdot G''.\gkey(v'')$ can be done by using the GCSA for de~Bruijn graph $G_{d} = (V, E)$ and the last character array $L$. If the lexicographic rank of \kmer{k} $X$ is $i$, the lexicographic rank of \kmer{k} $(cX)[0, k-1]$ is $G_{d}.\LF(i, c)$. If \kmer{2k} $X$ is encoded with \kmer{k} ranks $(i, j)$, we can encode string $cX$ as a lexicographic range of \kmer{k} rank sequences, with $(G_{d}.\LF(i, c), G_{d}.\LF(j, L[i]), G_{d}.\LF(0, L[j]))$ as the lower bound and $G_{d}.\LF(\abs{V_{d}}-1, L[j])$ as the last rank in the upper bound. String $c \cdot G''.\gkey(v'')$ prefix-matches key $G''.\gkey(u'')$ if and only the corresponding lexicographic ranges of \kmer{k} rank sequences overlap.


\end{document}
