\documentclass[a4paper,UKenglish]{lipics-v2016}

\usepackage{microtype}

\bibliographystyle{plainurl}

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Indexing Variation Graphs\footnote{This work was supported by the Wellcome Trust grant [098051].}}

\author[1]{Jouni Sirén}
\affil[1]{Wellcome Trust Sanger Institute, Hinxton, Cambridge, UK\\
  \texttt{jouni.siren@iki.fi}}
\authorrunning{J. Sirén}

\Copyright{Jouni Sirén}

\subjclass{E.1 Data Structures}
\keywords{Dummy keyword -- please provide 1--5 keywords}% FIXME
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Mathematics
\newcommand{\set}[1]{\ensuremath{\{ #1 \}}}
\newcommand{\abs}[1]{\ensuremath{\lvert #1 \rvert}}
\newcommand{\Oh}[1]{\ensuremath{\mathsf{O}\!\left( #1 \right)}}

% DNA
\newcommand{\dnaseq}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\baseA}{\dnaseq{A}}
\newcommand{\baseC}{\dnaseq{C}}
\newcommand{\baseG}{\dnaseq{G}}
\newcommand{\baseT}{\dnaseq{T}}
\newcommand{\baseN}{\dnaseq{N}}
\newcommand{\dnacomp}[1]{\ensuremath{\overline{#1}}}
\newcommand{\revcomp}[1]{\ensuremath{\overleftarrow{#1}}}

% Queries
\newcommand{\rank}{\ensuremath{\mathsf{rank}}}
\newcommand{\select}{\ensuremath{\mathsf{select}}}
\newcommand{\LF}{\ensuremath{\mathsf{LF}}}

% Graphs
\newcommand{\gindegree}{\ensuremath{\mathsf{in}}}
\newcommand{\goutdegree}{\ensuremath{\mathsf{out}}}
\newcommand{\glabel}{\ensuremath{\mathsf{label}}}
\newcommand{\gkey}{\ensuremath{\mathsf{key}}}
\newcommand{\gvalue}{\ensuremath{\mathsf{value}}}

% Shorthands
\newcommand{\kmer}[1]{$#1$\nobreakdash-mer}
\newcommand{\orderk}[1]{order\nobreakdash-$#1$}
\newcommand{\LFmapping}{LF\nobreakdash-mapping}
\newcommand{\FMindex}{FM\nobreakdash-index}

% Structures
\newcommand{\SA}{\ensuremath{\mathsf{SA}}}
\newcommand{\BWT}{\ensuremath{\mathsf{BWT}}}
\newcommand{\Carray}{\ensuremath{\mathsf{C}}}
\newcommand{\LCP}{\ensuremath{\mathsf{LCP}}}
\newcommand{\bvIN}{\ensuremath{\mathsf{IN}}}
\newcommand{\bvOUT}{\ensuremath{\mathsf{OUT}}}


\begin{document}

\maketitle

\begin{abstract}% FIXME
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti.
 \end{abstract}


\section{Introduction}

1000GP: \cite{1000GP2015}

Graph genomes: \cite{Schneeberger2009}

FM-index: \cite{Ferragina2005a}

CST-NPR: \cite{Fischer2009a}

CST MEMs: \cite{Ohlebusch2010a}

XBW: \cite{Ferragina2009b}

GCSA: \cite{Siren2014}

Succinct DBG: \cite{Bowe2012}, variable-order \cite{Boucher2014}, alternative representation \cite{Roedland2013}

BWBBLE: \cite{Huang2013}

Contracted DBG: \cite{Cazaux2014}

Compressed DBG: \cite{Marcus2014}

Manifold DBG: \cite{Lin2014}

Hypertext index: \cite{Thachuk2013}

FM-index of alignment: \cite{Na2015}

HISAT / HISAT2: \cite{Kim2015}


\section{Background}

\subsection{Strings}

A \emph{string} $S[0, n-1] = s_{0} \dotsm s_{n-1}$ of length $\abs{S} = n$ is a sequence of \emph{characters} over an \emph{alphabet} $\Sigma = \set{0, \dotsc, \sigma - 1}$. For indexing purposes, we often consider \emph{text} strings $T[0, n-1]$ terminated by an \emph{endmarker} $T[n-1] = \$ = 0$ not found anywhere else in the text. \emph{Binary} sequences are strings over the alphabet $\set{0, 1}$. A \emph{substring} of string $S$ is a sequence of the form $S[i, j] = s_{i} \dotsm s_{j}$. We call substrings of the type $S[0, j]$ and $S[i, n-1]$ \emph{prefixes} and \emph{suffixes}, respectively.

In this paper, we primarily consider sequences over the \emph{DNA} alphabet $\set{\$, \baseA, \baseC, \baseG, \baseT, \baseN}$. Characters $\baseA$, $\baseC$, $\baseG$, and $\baseT$ are called \emph{bases}, while character $\baseN$ represents an arbitrary or unknown base. In addition to the endmarker $\$$, the alphabet may also contain other characters for technical purposes. Each character $c$ of the DNA alphabet has a \emph{complement} $\dnacomp{c}$ defined as $\dnacomp{\baseA} = \baseT$, $\dnacomp{\baseC} = \baseG$, $\dnacomp{\baseG} = \baseC$, $\dnacomp{\baseT} = \baseA$, and $\dnacomp{c} = c$ for other characters $c$. Given a DNA sequence $S$, its \emph{reverse complement} is the sequence $\revcomp{S}$ obtained by reversing the non-technical parts of the sequence and replacing each character with its complement. For example, $\revcomp{\dnaseq{GATTACA}\$} = \dnaseq{TGTAATC}\$$.

Given string $S[0, n-1]$, we define $S.\rank(i, c)$ to be the number of occurrences of character $c$ in the prefix $S[0, i-1]$. We also define $S.\select(i, c) = \arg \max_{j \le n} S.\rank(j, c) < i$ as the position of the occurrence of character $c$ with rank $i > 0$.\footnote{These definitions correspond to the ones used in the SDSL library \cite{Gog2014b}.} A \emph{bitvector} is a binary sequence supporting efficient $\rank$/$\select$ queries. \emph{Wavelet trees} \cite{Grossi2003} are space-efficient data structures that use bitvectors to support $\rank$/$\select$ queries on arbitrary strings.

\subsection{Graphs}

A \emph{graph} $G = (V, E)$ consists of a set of \emph{nodes} $V = \set{0, \dotsc, \abs{V}-1}$ and a set of \emph{edges} $E \subseteq V \times V$. We say that $(u, v) \in E$ is an edge \emph{from} node $u$ \emph{to} node $v$, and assume that the edges are \emph{directed}: $(u, v) \ne (v, u)$ for $u \ne v$. The \emph{indegree} $G.\gindegree(v)$ of node $v$ is the number of \emph{incoming} edges to node $v$, while the \emph{outdegree} $G.\goutdegree(v)$ is the number of \emph{outgoing} edges from node $v$.

The graphs we consider are \emph{labeled} with alphabet $\Sigma$: each node $v \in V$ has a \emph{label} $G.\glabel(v) \in \Sigma$. A \emph{path} in a graph is a sequence of nodes $P = v_{0} \dotsm v_{\abs{P}-1}$ such that $(v_{i}, v_{i+1}) \in E$ for $0 \le i < \abs{P}-1$. The label of a path is the concatenation of node labels $G.\glabel(P) = G.\glabel(v_{0}) \dotsm G.\glabel(v_{\abs{P}-1})$.

We assume for convenience that all graphs have two special nodes: the \emph{source} node $s$ and the \emph{sink} node $t$. To distinguish them from the other nodes, we label them with characters $G.\glabel(s) = \#$ and $G.\glabel(t) = \$$ not used elsewhere in the graph. We add an edge $(s, v)$ for all nodes $v \in V \setminus \set{s}$ that have no other incoming edges, and an edge $(v, t)$ for all nodes $v \in V \setminus \set{t}$ with no other outgoing edges. We also add the edge $(t, s)$ to guarantee that $G.\gindegree(v) \ge 1$ and $G.\goutdegree(v) \ge 1$ for all nodes $v \in V$.

% FIXME example of strings, DBG, long paths, false positives
Let $\mathcal{S}$ be a (potentially infinite) collection of strings over alphabet $\Sigma$, each of them ending with $k$ copies of the endmarker $\$$. The \orderk{k} \emph{de~Bruijn graph} of $\mathcal{S}$ is a graph $G = (V, E)$, where each distinct \emph{\kmer{k}} (substring of length $k$) $X$ occurring in collection $\mathcal{S}$ is represented by a node $v_{X} \in V$. Each node $v_{X}$ has a \emph{key} $G.\gkey(v_{X}) = X$ and a label $G.\glabel(v_{X}) = X[0]$. The edges of the de~Bruijn graph represent \kmer{k+1}s $Y$ occurring in the collection. For each such substring $Y = cX$, where $c \in \Sigma$, we have an edge from node $v_{Y[0, k-1]}$ to node $v_{X}$. We use the node corresponding to substring $\$^{k}$ as the sink node, and add the source node (with $G.\gkey(s) = \#$) and the associated edges in the usual way. We may also have edges from the source node to the nodes representing the prefixes of the collection.

\begin{lemma}[No false negatives]
Let $G = (V, E)$ be an \orderk{k} de~Bruijn graph of string collection $\mathcal{S}$, and let $X$ be a substring of $\mathcal{S}$ not containing character $\$$. Then there is a path $P$ in the graph with $G.\glabel(P) = X$.
\end{lemma}

\begin{proof}
Let $X = S[i, i+\abs{X}-1]$ for a string $S \in \mathcal{S}$. For $i \le j \le i+\abs{X}-1$, there is node $v_{j} \in V$ representing substring $X_{j} = S[j, j+k-1]$, with $G.\glabel(v_{j}) = S[j]$. By definition, the de~Bruijn graph has an edge $(v_{j}, v_{j+1})$ for $i \le j < i+\abs{X}-1$. Hence $P = v_{i} \dotsm v_{i+\abs{X}-1}$ is a path in $G$ and $G.\glabel(P) = X$.
\end{proof}

\begin{lemma}[No false positives with $\abs{P} \le k+1$]
Let $G = (V, E)$ be an \orderk{k} de~Bruijn graph of string collection $\mathcal{S}$, and let $P$ be a path in $G$ with $\abs{P} \le k+1$. Then path $P$ either contains the source node $s$ or its label is a substring of a string $S \in \mathcal{S}$.
\end{lemma}

\begin{proof}
Assume that path $P = v_{0} \dotsm v_{\abs{P}-1}$ does not contain node $s$. If $\abs{P} = 0$, the label is an empty string and hence a substring of each string $S \in \mathcal{S}$. If $\abs{P} = 1$, the label is equal to $G.\glabel(v_{0})$, which is a prefix of $G.\gkey(v_{0})$ and hence a substring of $\mathcal{S}$.

Now assume that $G.\glabel(P) = cX$, where $c \in \Sigma \setminus \set{\#}$ and $1 \le \abs{X} \le k$. By induction, string $X$ is a prefix of $G.\gkey(v_{1})$. As edge $(v_{0}, v_{1})$ exists, $c \cdot G.\gkey(v_{1})$ must be a substring of $\mathcal{S}$. Hence $cX$ is a substring of $\mathcal{S}$, and also a prefix of $G.\gkey(v_{0})$ if $\abs{cX} \le k$.
\end{proof}

\subsection{Text indexes}

The \emph{suffix tree} \cite{Weiner1973} is the most fundamental full-text index supporting arbitrary substring queries. It is formed by taking the suffixes of the text, storing them in a trie, and compacting unary paths in the trie into single edges. Although fast and versatile, suffix trees are only of limited use in indexing large texts, as they require much more space than the text itself.

% FIXME SA/BWT/LCP example
\emph{Suffix arrays} \cite{Manber1993} were introduced as a space-efficient alternative to the suffix tree. The suffix array of text $T[0, n-1]$ is an array of pointers $\SA[0, n-1]$ to the suffixes of the text in \emph{lexicographic order}. Given a text and its suffix array, we can find the occurrences of \emph{pattern} string $X$ in the text by using \emph{binary search} in $\Oh{\abs{X} \log n}$ time. The suffix array requires $n \log n$ bits of space in addition to the $n \log \sigma$ bits used by the text --- still much more than the text --- while its functionality is more limited than that of the suffix tree.

The \emph{Burrows-Wheeler transform (BWT)} \cite{Burrows1994} is a permutation of the text sharing the combinatorial structure of the suffix array. The BWT of text $T[0, n-1]$ is a string $\BWT[0, n-1]$ defined as $\BWT[i] = T[(\SA[i]-1) \bmod n]$. Given the \emph{lexicographic rank} $i$ of suffix $T[\SA[i], n-1]$, we can use \emph{\LFmapping} on the BWT to find the lexicographic rank of the previous suffix $T[(\SA[i]-1) \bmod n, n-1]$. Let
$$
\LF(i) = \Carray[\BWT[i]] + \BWT.\rank(i, \BWT[i]),
$$
where $\Carray[c]$ is the number of suffixes of the text starting with any character $c' < c$. Then $\SA[\LF(i)] = (\SA[i]-1) \bmod n$. We can also generalize the definition for any character $c \in \Sigma$:
$$
\LF(i, c) = \Carray[c] + \BWT.\rank(i, c).
$$
Let $X$ be a string. If there are $i$ suffixes $S'$ of text $T$ such that $S' < X$ in lexicographic order, then there are $\LF(i, c)$ suffixes smaller than string $cX$ in lexicographic order.

Given the similarities to the suffix array, we can use the BWT as a space-efficient text index. The \emph{\FMindex} \cite{Ferragina2005a} combines a plain or compressed representation of the BWT supporting rank/select queries, the $\Carray$ array, and a set of \emph{sampled pointers} from the suffix array. It finds the \emph{lexicographic range} of suffixes matching pattern $X$ (having $X$ as a prefix) with a process called \emph{backward searching}. If the lexicographic range matching suffix $X[i+1, \abs{X}-1]$ of the pattern is $\SA[sp, ep]$, then the lexicographic range matching suffix $X[i, \abs{X}-1]$ of the pattern is $\SA[\LF(sp, X[i]), \LF(ep+1, X[i]) - 1]$. Finding the lexicographic range matching the entire pattern requires $\Oh{\abs{X}}$ rank queries.

We can use the sampled suffix array pointers to find the text positions containing the occurrences. If $\SA[i]$ is not sampled, we start iterating $\LF(i)$, until we find a sampled pointer. If we find a sample at $\SA[\LF^{k}(i)]$, we know that
$$
\SA[i] = (\SA[\LF^{k}(i)] + k) \bmod n.
$$
If we have sampled one out of $d$ suffix array pointers at regular intervals, finding each occurrence takes $\Oh{d}$ rank queries. If we also sample one out of $d'$ \emph{inverse suffix array} pointers\footnote{The suffix array is a permutation of $\set{0, \dotsc, n-1}$, and the inverse suffix array is the inverse permutation.}, we can \emph{extract} an arbitrary substring $X$ of the text using $\Oh{\abs{X}+d'}$ rank queries. In a typical case, we expect an \FMindex{} to take less than $n \log \sigma$ bits of space and to be able to find about 100,000 pattern occurrences per second \cite{Ferragina2009a}.

The \emph{longest-common-prefix array} (LCP array) \cite{Manber1993} is an integer array $\LCP[0, n-1]$, where each value $\LCP[i]$ tells the length of the longest common prefix of suffixes $T[\SA[i-1], n-1]$ and $T[\SA[i], n-1]$ (with $\LCP[0] = 0$). It is often used to augment the functionality of the suffix array and the \FMindex. In particular, if we augment the \FMindex{} with the LCP array and the topology of the suffix tree, we get the \emph{compressed suffix tree}, which supports the full functionality of the suffix tree in a space-efficient manner \cite{Sadakane2007}.

\subsection{Generalized indexes}

Suffix trees, suffix arrays, and \FMindex{} can be generalized to index multiple texts. There are also generalizations for other combinatorial structures. The \emph{XBW transform} \cite{Ferragina2009b} is essentially an \FMindex{} for \emph{labeled trees}. The nodes of the tree are sorted by path labels from the node to the root of the tree. $\BWT$ stores the labels of the children of each node (leaf nodes require special treatment). If a node has $k$ children, we encode that as binary sequence $0^{k-1} 1$. We concatenate these sequences to form bitvector $B$, which is used for mapping lexicographic ranks of nodes to the corresponding BWT ranges. The labels of the children of node $i$ are found in $\BWT[B.\select(i, 1) + 1, B.\select(i + 1, 1)]$ (with $0$ as the lower bound for $i = 0$).

% FIXME LF(i, c) picture from the slides for the earlier DBG example
The \emph{generalized compressed suffix array} (GCSA) \cite{Siren2014} is a further generalization of the XBW transform for a class of graphs that includes \emph{directed acyclic graphs} and \emph{de Bruijn graphs}. Before a graph can be indexed, we have to transform it into an equivalent graph, where the nodes can be unambiguously sorted by the labels of the paths starting from them. The transformation is expensive and may increase the size of the graph exponentially. After sorting the nodes of the transformed graph, we encode them using three sequences. $\BWT$ contains the labels of the predecessors, while bitvectors $\bvIN$ and $\bvOUT$ encode the indegrees and outdegrees of each node in the same way as bitvector $B$ of the XBW transform. \LFmapping{} uses select queries on bitvector $\bvIN$ to map nodes into BWT ranges, ordinary \LFmapping{} with $\BWT$ to map incoming edges into the corresponding outgoing edges, and rank queries on bitvector $\bvOUT$ to map the outgoing edges to the predecessor nodes.


\section{Path indexes}

A \emph{path index} is a generalization of text indexes for \emph{labeled graphs}. Given a path index for graph $G = (V, E)$, we want to use the index to find the \emph{start nodes} $v_{0} \in V$ of the paths $P = v_{0} \dotsm v_{\abs{X}-1}$ \emph{matching} the pattern $X$ (paths $P$ with $G.\glabel(P) = X$).

The design of a path index is a trade-off between the maximum supported query length and the size of the index. In the worst case, a graph may have up to $(\sigma-2)^{k}$ distinct labels for paths of length $k$ (ignoring paths containing the source node or the sink node), and the length of possible paths is unlimited in cyclic graphs. GCSA \cite{Siren2014} tried to avoid this by considering only a relatively simple class of graphs, using \emph{pruning heuristics} to simplify the graphs when necessary. The price of this was the possibility of \emph{false negatives}: path labels that exist in the graph but not in the index.

% FIXME from here
k-mer indexes based on hash tables, sorted k-mers

similarities between k-mer indexes and de Bruijn graphs: order-k+1 index can simulate order-k DBG; order-k DBG can be used as an order-k index

define de Bruijn graphs for graphs (infinite strings, no source node, repeat sink node instead)

using de Bruijn graphs as indexes; false positives
- string Y matches node with key X: X is a prefix of Y or Y is a prefix of X
- add values (pointers to start nodes) to each node
- valid for existence queries of length up to k+1 and locate queries of length up to k

Path graphs
- a generalization of DBG as a path index
- keys must be prefix-free
- k-index: has a node matching any k-path in the input graph
- edge condition: Y has predecessor with c -> edge (X, Y) if cY matches X
- k-equivalent: union of values for nodes matching X identical for all |X| <= k
- k-equivalent + edge condition: no false positives of length <= k; no false negatives

pruned de Bruijn graphs: merge nodes of DBG while keeping the path graph k-equivalent


\section{GCSA2}


\section{Construction}


\section{Experiments}


\section{Discussion}


% FIXME
\subparagraph*{Acknowledgements.}

I want to thank \dots


\bibliography{paper}


\end{document}
